/*
 *  This file is distributed under the MIT License.
 *  See LICENSE file for details.
 */
#pragma once

// properties shared by compiler + VM
typedef enum:unsigned char {

	//-- COMPILER/VM TYPE VAR
	BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_UNDEFINED = 0,	// 0x1
	BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_NULL,			// 0x2
	BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_INTEGER,		// 0x4
	BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_FLOAT,			// 0x8
	BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_BOOLEAN,		// 0x10
	BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_STRING,			// 0x20
	BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_FUNCTION,		// 0x40
	BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_SCRIPTVAR,		// 0x80
	BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_MAX,
	//-- VM RUNTIME
	BIT_STACK_ELEMENT_PROPERTY_IS_VAR_C = BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_MAX, // 0x100
	BIT_STACK_ELEMENT_PROPERTY_IS_VAR_STACK_ELEMENT,	 // 0x200
	BIT_STACK_ELEMENT_PROPERTY_IS_VAR_INSTRUCTION,		 // 0x400
	BIT_STACK_ELEMENT_PROPERTY_POP_ONE,				 	 // 0x800
	BIT_STACK_ELEMENT_PROPERTY_UNRESOLVED_FUNCTION,		 // 0x1000
	BIT_STACK_ELEMENT_PROPERTY_CONSTRUCTOR_FUNCTION,	 // 0x2000
	BIT_STACK_ELEMENT_PROPERTY_IS_VAR_THIS,				 // 0x4000
	BIT_STACK_ELEMENT_PROPERTY_READ_ONLY,				 // 0x8000
	MAX_BIT_RUNTIME

}StackElementProperty;

enum
	:unsigned short {
	MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_UNDEFINED = (0x1 << BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_UNDEFINED), // let's say a variable not defined...
	MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_NULL = (0x1 << BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_NULL), // let's say a variable is null assigned ..
	MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_INTEGER = (0x1 << BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_INTEGER), // primitive int
	MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_FLOAT = (0x1 << BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_FLOAT), // primitive number
	MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_BOOLEAN = (0x1 << BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_BOOLEAN), // primitive bool
	MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_STRING = (0x1 << BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_STRING), // constant / script var
	MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_FUNCTION = (0x1 << BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_FUNCTION), // primitive function
	MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_SCRIPTVAR = (0x1 << BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_SCRIPTVAR) // always is an script class...

};

#define MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_TYPE_PRIMITIVES					((0x1<<BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_FUNCTION)-1)
#define GET_INS_PROPERTY_PRIMITIVE_TYPES(prop)								((prop)&MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_TYPE_PRIMITIVES)

#define MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_TYPES							((0x1<<BIT_STACK_ELEMENT_PROPERTY_VAR_TYPE_MAX)-1)
#define GET_MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_TYPES(prop)					((prop)&MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_TYPES)

enum:unsigned short {
	MSK_STACK_ELEMENT_PROPERTY_IS_VAR_C = (0x1 << BIT_STACK_ELEMENT_PROPERTY_IS_VAR_C),
	MSK_STACK_ELEMENT_PROPERTY_IS_VAR_STACK_ELEMENT = (0x1 << BIT_STACK_ELEMENT_PROPERTY_IS_VAR_STACK_ELEMENT),
	MSK_STACK_ELEMENT_PROPERTY_IS_VAR_INSTRUCTION = (0x1 << BIT_STACK_ELEMENT_PROPERTY_IS_VAR_INSTRUCTION),
	MSK_STACK_ELEMENT_PROPERTY_POP_ONE = (0x1 << BIT_STACK_ELEMENT_PROPERTY_POP_ONE),
	MSK_STACK_ELEMENT_PROPERTY_UNRESOLVED_FUNCTION = (0x1 << BIT_STACK_ELEMENT_PROPERTY_UNRESOLVED_FUNCTION),
	MSK_STACK_ELEMENT_PROPERTY_CONSTRUCTOR_FUNCTION = (0x1 << BIT_STACK_ELEMENT_PROPERTY_CONSTRUCTOR_FUNCTION),
	MSK_STACK_ELEMENT_PROPERTY_IS_VAR_THIS = (0x1 << BIT_STACK_ELEMENT_PROPERTY_IS_VAR_THIS),
	MSK_STACK_ELEMENT_PROPERTY_READ_ONLY = (0x1 << BIT_STACK_ELEMENT_PROPERTY_READ_ONLY)
};

#define MSK_STACK_ELEMENT_PROPERTY_RUNTIME					(((0x1<<(MAX_BIT_RUNTIME-BIT_STACK_ELEMENT_PROPERTY_IS_VAR_C))-1)<<(BIT_STACK_ELEMENT_PROPERTY_IS_VAR_C))
#define GET_MSK_STACK_ELEMENT_PROPERTY_RUNTIME(prop)		((prop)&MSK_STACK_ELEMENT_PROPERTY_RUNTIME)


#define STK_VALUE_IS_FLOAT_OR_INT(stk)\
	(stk->properties & (MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_FLOAT|MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_INTEGER))

// Check types
#define STK_VALUE_IS_FLOAT(stk) \
(stk->properties & MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_FLOAT)


#define STK_VALUE_IS_INT(stk) \
(stk->properties & MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_INTEGER)


#define STK_VALUE_IS_STRING(stk) \
(stk->properties & MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_STRING)

#define STK_VALUE_IS_CHAR_PTR(stk) \
(stk->properties & STK_PROPERTY_TYPE_CHAR_PTR)

#define STK_VALUE_IS_BOOLEAN(stk) \
(stk->properties & MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_BOOLEAN)

#define STK_VALUE_IS_UNDEFINED(stk) \
(stk->properties & MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_UNDEFINED)

#define STK_VALUE_IS_FUNCTION(stk) \
(stk->properties & MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_FUNCTION)

#define STK_VALUE_IS_SCRIPT_VAR(stk) \
(stk->properties & MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_SCRIPTVAR)

#define STK_VALUE_IS_VECTOR(stk) \
(( stk->properties & MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_SCRIPTVAR) &&\
 (((ScriptVar *)(stk->stk_value))->idx_class==IDX_BUILTIN_TYPE_CLASS_VECTOR))

/*#define STK_VALUE_IS_INT_OR_FLOAT(properties) \
((properties & MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_INTEGER) ||\
(properties & MSK_STACK_ELEMENT_PROPERTY_VAR_TYPE_FLOAT))*/

#define STK_VALUE_TO_INT(ptr_result_instruction) \
		((int)((intptr_t)(ptr_result_instruction->stk_value)))

#define STK_VALUE_TO_BOOL(ptr_result_instruction) \
		(((bool)(ptr_result_instruction->stk_value)))


#define STK_VALUE_TO_STRING(ptr_result_instruction) \
		(((const char *)(ptr_result_instruction->stk_value)))

namespace zetscript{

	#pragma pack(push, 1)

	struct StackElement {
		//VALUE_INSTRUCTION_TYPE 		type; // tells what kind of variable is. By default is object.
		void * stk_value; // operable value
		void * var_ref; // stack ref in case to assign new value.
		unsigned short properties; // it tells its properties


		// it returns its type...
		const char * typeStr();
		// it gives stackelement as string (the result should be deleted)
		const char * toString();

	};

	#pragma pack(pop)


	typedef StackElement ConstantValue;


}
