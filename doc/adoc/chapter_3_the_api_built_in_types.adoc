
=== Types

This section wil describe the types used in the library in order to interop data native/script and the ZetScript class, the core the most operations in the library.

==== zs_int

Integer data type it defines a integer variable with range from -(2^b-1^)` to `2^b-1^-1 where `b=32` or `b=64` it depending whether ZetScript is compiled for 32bits or 64bits. 

*Example*

[source,c++]
----
zetscript::zs_int i=10;
----

==== zs_float

_zs_float_ type it defines a float variable represented as IEEE-754 floating point numbers in 32-bit or 64 bit it depending whether ZetScript is compiled for 32bits or 64bits.

*Example*

[source,c++]
----
zetscript::zs_float f=20.5;
----

==== zs_string

_zs_string_ it defines a string represented a sequence of chars

*Example*

[source,c++]
----
zetscript::zs_string s="Hello World";
----

===== Member functions

_zs_string_ has the following member functions,

====== zs_string::operator=()

Assigns a new value to the string, replacing its current contents.

	zs_string& operator=(const zs_string & obj);
		zs_string& operator=(zs_string && _str_tmp);
		zs_string& operator=(const char* buffer);

======  zs_string::operator+=()

Appends __string_ at the end of current contents.

		zs_string& operator+=(const zs_string& rhs);
		zs_string& operator+=(const char* buffer);
		zs_string& operator+=(char _c);

====== zs_string::operator[]()

Returns a reference to the character at position __pos_.

	    char& operator[] (int pos);
	    const char& operator[] (int _pos) const;

====== zs_string::at()

Returns a reference to the character at position __pos_.

	    char& at (int pos);
	    const char& at (int _pos) const;

====== zs_string::clear()

Erases the contents of the string.

	    void clear();

====== zs_string::substr()

Returns a new string with its value initialized to a copy of a substring of this object. The substring is the portion of the object that starts at character position __pos_ and spans _&#x5f;len_ characters.

zs_string  substr (int pos = 0, int len = npos) const;

======  zs_string::find()

Searches the string for the first occurrence of the sequence specified by its arguments. When _&#x5f;pos_ is specified, the search only includes characters at or after position _&#x5f;pos_, ignoring any possible occurrences that include characters before _&#x5f;pos_.



		int find(const zs_string &_s, int _pos = 0) const;
		int find(const char *_s, int _pos = 0) const;

====== zs_string::find_last_of()

Searches the string for the last character that matches any of the characters specified in its arguments. When _&#x5f;pos_ is specified, the search only includes characters at or before position _&#x5f;pos_, ignoring any possible occurrences after _&#x5f;pos_.

int find_last_of(const char *_s, int _pos = npos) const;

====== zs_string::replace()

Replaces the portion of the string that begins at character _&#x5f;pos_ and spans _&#x5f;len_ characters.

zs_string & replace(int _pos, int _len, const zs_string & _to_replace);

====== zs_string::append()

Appends __string_ at the end of current contents.

		void append(const char *buf, int _len);
		void append(char _c);
		void append(const zs_string & _s);
		void append(const char * _s);

====== zs_string::erase()

Erases part of the string, reducing its length.

		void erase(int _pos, int _len);
		void erase(int _pos);

====== zs_string::insert()

Inserts additional characters into the string right before the character indicated by _&#x5f;pos_.


		void insert(int _pos, char _c);
		void insert(int _pos, const zs_string & _s1);

====== zs_string::empty()

Returns whether the string is empty.

		bool empty() const;

====== zs_string::length()

Returns the length of the string, in terms of bytes.

		inline int length() const{
			return count;
		}

====== zs_string::c_str()

Returns a pointer to an array that contains a null-terminated sequence of characters (i.e., a C-string) representing the current value of the string object.

const char * c_str() const;

===== Static functions

_zs_string_ has the following static functions,

====== zs_string::operator+()

Returns a new string object with its value being the concatenation of the characters in left operand followed by those of right operand.

		friend zs_string operator+(const zs_string & _s1, const zs_string &_s2);
		friend zs_string operator+(const zs_string & _s1, const char *_s2);
		friend zs_string operator+(const char * _s1, const zs_string & _s2);

		friend zs_string operator+(const zs_string & _s1, char _s2);
		friend zs_string operator+(char  _s1, const zs_string & _s2);


====== zs_string::operator==()

Performs the EQUAL comparison operation between the left operand and right operand.

		friend bool operator==(const zs_string & _s1, const zs_string &_s2);
		friend bool operator==(const zs_string & _s1, const char *_s2);
		friend bool operator==(const char * _s1, const zs_string & _s2);


====== zs_string::operator!=()

Performs the NOT EQUAL comparison operation between the left operand and right operand.

		friend bool operator!=(const zs_string & _s1, const zs_string &_s2);
		friend bool operator!=(const zs_string & _s1, const char *_s2);
		friend bool operator!=(const char * _s1, const zs_string & _s2);



==== zs_vector

===== Member functions

====== zs_vector::operator=()

zs_vector& operator=(const zs_vector& _obj);		

====== zs_vector::set()
		
		void 		set( int  _idx, const _T & _val);

====== zs_vector::get()

		const _T &	get( int  _idx);

====== zs_vector::erase()
		void 		erase( int  _idx);

====== zs_vector::push_back()

		bool 		push_back( const _T & _val);

====== zs_vector::concat()        
		void 		concat(const zs_vector<_T>  & _vector);

====== zs_vector::insert()        
		void 		insert(int _idx,const zs_vector<_T>  & _vector, int _n_list_elements_to_copy=npos);

		void 		insert(int  idx, const _T & _val);

====== zs_vector::clear()
		void 		clear();

====== zs_vector::pop_back()
		_T    		pop_back();

====== zs_vector::resize()
		void    	resize(int _len);


====== zs_vector::data()
		inline _T *data(){
			return items;
		}

====== zs_vector::size()

		inline int	size() const{
			return count;
		}

==== StackElement

===== Propeties

value

bla,bla,bla

properties

	typedef enum:unsigned short {
		//---------- BEGIN PRIMITIVE TYPES HERE--------------------
		ZS_STK_PROPERTY_UNDEFINED				=0x0000,
		ZS_STK_PROPERTY_NULL					=0x0001,
		ZS_STK_PROPERTY_CHAR_PTR			=0x0002,
		ZS_STK_PROPERTY_INT					=0x0004,
		ZS_STK_PROPERTY_FLOAT				=0x0008,
		ZS_STK_PROPERTY_BOOL					=0x0010,
		ZS_STK_PROPERTY_TYPE					=0x0020,
		//---------- END PRIMITIVE TYPES HERE--------------------
		ZS_STK_PROPERTY_FUNCTION				=0x0040,
		ZS_STK_PROPERTY_MEMBER_FUNCTION		=0x0080,
		ZS_STK_PROPERTY_MEMBER_PROPERTY		=0x0100,
		ZS_STK_PROPERTY_SCRIPT_OBJECT			=0x0200,
		ZS_STK_PROPERTY_CONTAINER_SLOT			=0x0400,
		ZS_STK_PROPERTY_MAX					=0x0800,
		//-- VM RUNTIME
		ZS_STK_PROPERTY_PTR_STK				= ZS_STK_PROPERTY_MAX,	 				// 0x1000
		ZS_STK_PROPERTY_READ_ONLY				=0x1000,

	}StkProperty;


===== Member functions

====== StackElement::setUndefined

		void 					setUndefined();

====== StackElement::typeOf

		StackElement			typeOf();

==== StringScriptObject

_StringScriptObject_ it defines a string script object and encapsules _zs_string_ reference. It uses zetscript context in order to be instanced

===== Member functions

_ArrayScriptObject_ member functions available for user operations are the following,

====== StringScriptObject::set()

Replaces current string value.

void set(const zs_string & _s);

====== StringScriptObject::get()

const zs_string & get();

====== StringScriptObject::getConstChar()

		const char *getConstChar();

====== StringScriptObject::length()

		virtual int length();

====== StringScriptObject::toString()

		virtual zs_string toString();

==== ScriptFunction

_ScriptFunction_ it defines a function object that contains function information. 


==== ZetScript


===== ZetScript::eval()
		StackElement	eval(const zs_string & expresion,unsigned short _eval_options, const char * _script_file_by_ref="", const char *__invoke_file__="", int __invoke_line__=-1);

		StackElement	eval(const zs_string & expresion, const char *__invoke_file__="", int __invoke_line__=-1);


===== ZetScript::evalFile()
		StackElement	evalFile(const zs_string & _filename,unsigned short _eval_options=0, EvalData *_eval_data_from=NULL, const char *__invoke_file__="", int __invoke_line__=-1);


===== ZetScript::intToStackElement()

		StackElement   			intToStackElement(zs_int);

===== ZetScript::floatToStackElement()

		StackElement    		floatToStackElement(zs_float);

===== ZetScript::boolToStackElement()

		StackElement    		boolToStackElement(bool);

===== ZetScript::stackElementTo()
		template<typename _C>
		_C stackElementTo(StackElement   _stk);

===== ZetScript::stackElementToString()
		zs_string		stackElementToString(StackElement _stk,const zs_string & _format="");

===== ZetScript::stackElementToStringTypeOf()
		zs_string		stackElementToStringTypeOf(StackElement _stk);

===== ZetScript::toStackElement()
		template<typename _C>
		StackElement	toStackElement( _C _val);

===== ZetScript::ObjectScriptObject_new()
		ObjectScriptObject * newObjectScriptObject();

===== ZetScript::ObjectScriptObject_set()
===== ZetScript::ObjectScriptObject_get()

===== ZetScript::StringScriptObject_new()
		StringScriptObject * newStringScriptObject(const zs_string & _str="");

===== ZetScript::StringScriptObject_set()
===== ZetScript::StringScriptObject_get()


===== ZetScript::ArrayScriptObject_new()
		ArrayScriptObject * newArrayScriptObject();

===== ZetScript::newClassScriptObject()
		template<typename _C>
		ClassScriptObject * newClassScriptObject(_C  *_instance=NULL);


===== ZetScript::registerConstant()


		void registerConstant(const zs_string & var_name, int value, const char *registered_file="", short registered_line=-1);
		void registerConstant(const zs_string & var_name, zs_float value, const char *registered_file="", short registered_line=-1);
		void registerConstant(const zs_string & var_name, bool value, const char *registered_file="", short registered_line=-1);
		void registerConstant(const zs_string & var_name, const zs_string & v, const char *registered_file="", short registered_line=-1);
		void registerConstant(const zs_string & var_name, const char * v, const char *registered_file="", short registered_line=-1);

		// register object
		StackElement * registerStkConstantStringObject(const zs_string & _key,const zs_string & _value);

		StackElement * getStkConstantStringObject(const zs_string & _key);


===== ZetScript::registerType()

		template<typename T>
		ScriptType * registerType(
				const zs_string & str_script_type
				, T  * (*_new_native_instance)(ZetScript *_zs)=NULL
				, void (*_delete_native_instance)(ZetScript *_zs,T *)=NULL
				, const char *_registered_file="",short _registered_line=-1
		)


===== ZetScript::registerFunction()

		template <typename F>
		void registerFunction( const zs_string & _name_script_function,F ptr_function, const char *_registered_file="",short _registered_line=-1)


===== ZetScript::extends()

		template<class T, class B>
		void extends()

===== ZetScript::registerConstructor()        

		template<typename T,typename F>
		void registerConstructor(
				 F function_type
				 , const char *_registered_file=""
				,short _registered_line=-1
		)

===== ZetScript::registerMemberFunction()

		template <typename T,typename F>
		void	registerMemberFunction(
				const zs_string & _name_script_function
				,F function_type
				 , const char *_registered_file=""
				,short _registered_line=-1
		)

===== ZetScript::registerConstMemberProperty()        

		template <typename T,typename F>
		void	registerConstMemberProperty(
				const zs_string & _property_name
				,F ptr_function
				 , const char *_registered_file=""
				,short _registered_line=-1
		)


===== ZetScript::registerMemberPropertyMetamethod()

		template <typename T,typename F>
		void	registerMemberPropertyMetamethod(
				const zs_string & _property_name
				,const zs_string & _metamethod_name
				,F _ptr_function
				 , const char *_registered_file=""
				,short _registered_line=-1
		);

===== ZetScript::registerStaticMemberFunction()

		template <typename T,typename F>
		void registerStaticMemberFunction(const zs_string & _name_script_function,F _fun, const char *_registered_file="",short _registered_line=-1);

===== ZetScript::unrefLifetimeObject()        

		void unrefLifetimeObject(ScriptObject *so);

===== ZetScript::bindScriptFunction()        

		template <  typename F>
		std::function<F> bindScriptFunction(const zs_string & function_access, const char *_file="", int _line=-1);

		template <  typename F>
		std::function<F> bindScriptFunction(MemberFunctionScriptObject *_sf, const char *_file="", int _line=-1);

		template <  typename F>
		std::function<F> bindScriptFunction(ScriptFunction *_sf, ScriptObject *_calling_object, const char *_file="", int _line=-1);

		template <  typename F>
		std::function<F> bindScriptFunction(ScriptFunction *_sf, const char *_file="", int _line=-1);


===== ZetScript::clear()
		void clear();

===== ZetScript::saveState()
		void saveState();


==== ArrayScriptObject

_ArrayScriptObject_ it defines a array script object that acts as a array container of elements. It uses zetscript context in order to be instanced.

===== Member functions

_ArrayScriptObject_ member functions available for user operations are the following,

====== ArrayScriptObject::push()

Appends _&#x5f;value_  of type _&#x5f;T_ at the end of array.

		template<typename _T>
		void 								push(_T _value);

====== ArrayScriptObject::set()

Replaces current value at position _&#x5f;pos_ by _&#x5f;value_ of type _&#x5f;T_.

	template<typename _T>
		void 								set(int _idx, _T _value);


====== ArrayScriptObject::get()

Returns a reference element of type _&#x5f;T_ at position __pos_.

		template<typename _T>
		_T 									get(int _idx);

====== ArrayScriptObject::toString()

virtual 							zs_string toString();

==== ObjectScriptObject

_ObjectScriptObject_ it defines a object script object that acts as a container of fields. It uses zetscript context in order to be instanced.


===== Member functions

_ObjectScriptObject_ member functions available for user operations are the following,

====== ObjectScriptObject::set()

Replaces current value at key _&#x5f;key_ by _&#x5f;value_ of type _&#x5f;T_.

====== ObjectScriptObject::get()

Returns element of type _&#x5f;T_ from key __key_.

==== ClassScriptObject

_ClassScriptObject_ it a subclass of _ObjectScriptObject_ that implements the _class_ type defined in ZetScript. Also it is used as a wrapper for instanced of registered C++ types.

