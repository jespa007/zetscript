<<<
==== Register metamethods

the ScriptEngine API allows to register static and member metamethods in aim to define operators as we could see in xref:language_class.adoc#_metamethods[chapter 2 class metamethods].

===== Member metamethods

====== _tostring()

Returns custom string when string operation operation is invoved

*Syntax*

[source,cpp]
----
String RegisteredType_tostring(ScriptEngine * _se, RegisteredType *_this);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance


[.underline]#Returns#

A String as a result when string operation operation is invoved

*Example*

The following code defines a function that converts and returns current value as string,

[source,cpp]
----

String NumberZs_tostring(ScriptEngine *_se,Number *_this){
	char output[100];
	sprintf(output,"%0.2f",_this->value);
	return output;
}


----

Next, the function _NumberZs_tostring_ is registered as member metamethod __tostring_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----


void NumberZs_register(zetscript::ScriptEngine *_se){

	//...

	_se->registerMemberFunction<Number>("_tostring",&NumberZs_tostring));

	//...
}
----

Finally, the following code it shows an example of a script that creates a type _Number_ and prints its content to the console through _Console::outln_. Because _Console::outln_ prints string information it calls __tostring_ implicitly.

[source,cpp]
----
include::../examples/api/register_type/register_member_metamethod_tostring.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_tostring_out.txt[]
----

<<<

====== _set()

Implements _assignment_ operator (aka = ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_set(ScriptEngine * _se, RegisteredType *_this, ParamType * _value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : A value to be set. Its type can be a pointer of one defined in  xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions performs an assignment from xref:language_data_types.adoc#&lowbar;float[Float] value or _Number_ object respectively,

[source,cpp]
----

void NumberZs_set(ScriptEngine *_se,Number *_this, zs_float *_n){
	_this->value=*_n;
}

void NumberZs_set(ScriptEngine *_se,Number *_this,Number *_n){
	 _this->value = _n->value;
}

----

Next, each function _NumberZs_set_ function is registered as member metamethod __set_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){

	//...

	_se->registerMemberFunction<Number>("_set",static_cast<void (*)(ScriptEngine *_se,Number *, zs_float *)>(&NumberZs_set));

	_se->registerMemberFunction<Number>("_set",static_cast<void (*)(ScriptEngine *_se,Number *,Number *)>(&NumberZs_set));

	//...

}
----

Finally, the following code it shows an example of a script that assigns  values from a _Float_ value and _Number_ object.

[source,cpp]
----
include::../examples/api/register_type/register_member_metamethod_set.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_set_out.txt[]
----

<<<

====== _addset()

Implements _addition assignment_ operator (aka += ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_addset(ScriptEngine *_se, RegisteredType *_this,ParamType *_value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : Value or variable as right operand. Its type can be a pointer of one defined in xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions that performs an addition and assignment to the current instance from  a _Float_ value or _Number_ object respectively,

[source,cpp]
----

void NumberZs_addset(ScriptEngine *_se, Number *_this,zs_float *_n){
	_this->value+=*_n;
}

void NumberZs_addset(ScriptEngine *_se, Number *_this,Number *_n){
	_this->value+=_n->value;
}
----

Next, each function _NumberZs_addset_ is registered as member metamethod __addset_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerMemberFunction<Number>("_addset",static_cast<void (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_addset));

	_se->registerMemberFunction<Number>("_addset",static_cast<void (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_addset));
	//...

}
----

Finally, the following code it shows an example of a script that add and assigns values from a _Float_ value and _Number_  object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_addset.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_addset_out.txt[]
----

<<<

====== _subset()

Implements _substraction assignment_ operator (aka -= ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_subset(ScriptEngine *_se, RegisteredType *_this,ParamType *_value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : Value or variable as right operand. Its type can be a pointer of one defined in xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions that performs a substraction and assignment to the current instance from a _Float_ value or _Number_ type respectively,

[source,cpp]
----

void NumberZs_subset(ScriptEngine *_se, Number *_this,zs_float *_n){
	_this->value-=*_n;
}

void NumberZs_subset(ScriptEngine *_se, Number *_this,Number *_n){
	_this->value-=_n->value;
}
----

Next, each function _NumberZs_subset_ is registered as member metamethod __subset_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerMemberFunction<Number>("_subset",static_cast<void (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_subset));

	_se->registerMemberFunction<Number>("_subset",static_cast<void (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_subset));
	//...
}
----

Finally, the following code it shows an example of a script that substracts and assigns values from a _Float_ value and _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_subset.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_subset_out.txt[]
----

<<<

====== _mulset()

Implements _multiplication assignment_ operator (aka *= ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_mulset(ScriptEngine *_se, RegisteredType *_this,ParamType *_value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : Value or variable as right operand. Its type can be a pointer of one defined in xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions that performs a multiplication and assignment to the current instance from a _Float_ value or _Number_ type respectively,

[source,cpp]
----

void NumberZs_mulset(ScriptEngine *_se, Number *_this,zs_float *_n){
	_this->value-=*_n;
}

void NumberZs_mulset(ScriptEngine *_se, Number *_this,Number *_n){
	_this->value-=_n->value;
}
----

Next, each function _NumberZs_mulset_ is registered as member metamethod __mulset_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerMemberFunction<Number>("_mulset",static_cast<void (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_mulset));

	_se->registerMemberFunction<Number>("_mulset",static_cast<void (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_mulset));
	//...
}
----

Finally, the following code it shows an example of a script that multiples and assigns values from a _Float_ value and _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_mulset.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_mulset_out.txt[]
----

<<<

====== _divset()

Implements _division assignment_ operator (aka /= ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_divset(ScriptEngine *_se, RegisteredType *_this,ParamType *_value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : Value or variable as right operand. Its type can be a pointer of one defined in xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions that performs a division and assignment to the current instance from a _Float_ value or _Number_ type respectively,

[source,cpp]
----

void NumberZs_divset(ScriptEngine *_se, Number *_this,zs_float *_n){
	_this->value-=*_n;
}

void NumberZs_divset(ScriptEngine *_se, Number *_this,Number *_n){
	_this->value-=_n->value;
}
----

Next, each function _NumberZs_divset_ is registered as member metamethod __divset_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerMemberFunction<Number>("_divset",static_cast<void (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_divset));

	_se->registerMemberFunction<Number>("_divset",static_cast<void (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_divset));
	//...
}
----

Finally, the following code it shows an example of a script that divides and assigns values from a _Float_ value and _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_divset.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_divset_out.txt[]
----

<<<

====== _modset()

Implements _modulus assignment_ operator (aka %= ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_modset(ScriptEngine *_se, RegisteredType *_this,ParamType *_value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : Value or variable as right operand. Its type can be a pointer of one defined in xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions that performs a remainder division and assignment to the current instance from a _Float_ value or _Number_ type respectively,

[source,cpp]
----

void NumberZs_modset(ScriptEngine *_se, Number *_this,zs_float *_n){
	_this->value-=*_n;
}

void NumberZs_modset(ScriptEngine *_se, Number *_this,Number *_n){
	_this->value-=_n->value;
}
----

Next, each function _NumberZs_modset_ is registered as member metamethod __modset_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerMemberFunction<Number>("_modset",static_cast<void (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_modset));

	_se->registerMemberFunction<Number>("_modset",static_cast<void (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_modset));
	//...

}
----

Finally, the following code it shows an example of a script that produces the remainder division and assigns values from a _Float_ value and _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_modset.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_modset_out.txt[]
----

<<<

====== _andset()

Implements _bitwise AND assignment_ operator (aka &= ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_andset(ScriptEngine *_se, RegisteredType *_this,ParamType *_value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : Value or variable as right operand. Its type can be a pointer of one defined in xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions that performs a bitwise AND and assignment to the current instance from a _Float_ value or _Number_ type respectively,

[source,cpp]
----

void NumberZs_andset(ScriptEngine *_se, Number *_this,zs_float *_n){
	_this->value-=*_n;
}

void NumberZs_andset(ScriptEngine *_se, Number *_this,Number *_n){
	_this->value-=_n->value;
}
----

Next, each function _NumberZs_andset_ is registered as member metamethod __andset_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerMemberFunction<Number>("_andset",static_cast<void (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_andset));

	_se->registerMemberFunction<Number>("_andset",static_cast<void (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_andset));
	//...

}
----

Finally, the following code it shows an example of a script that performs a bitwise AND and assignment from a _Float_ value and _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_andset.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_andset_out.txt[]
----

<<<

====== _orset()

Implements _bitwise OR assignment_ operator (aka |= ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_orset(ScriptEngine *_se, RegisteredType *_this,ParamType *_value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : Value or variable as right operand. Its type can be a pointer of one defined in xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions that performs a bitwise OR and assignment to the current instance from a _Float_ value or _Number_ type respectively,

[source,cpp]
----

void NumberZs_orset(ScriptEngine *_se, Number *_this,zs_float *_n){
	_this->value-=*_n;
}

void NumberZs_orset(ScriptEngine *_se, Number *_this,Number *_n){
	_this->value-=_n->value;
}
----

Next, each function _NumberZs_orset_ is registered as member metamethod __orset_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerMemberFunction<Number>("_orset",static_cast<void (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_orset));

	_se->registerMemberFunction<Number>("_orset",static_cast<void (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_orset));
	//...

}
----

Finally, the following code it shows an example of a script that performs a bitwise OR and assignment from a _Float_ value and _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_orset.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_orset_out.txt[]
----

<<<

====== _xorset()

Implements _bitwise XOR assignment_ operator (aka ^= ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_xorset(ScriptEngine *_se, RegisteredType *_this,ParamType *_value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : Value or variable as right operand. Its type can be a pointer of one defined in xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions that performs a bitwise XOR and assignment to the current instance from a _Float_ value or _Number_ type respectively,

[source,cpp]
----

void NumberZs_xorset(ScriptEngine *_se, Number *_this,zs_float *_n){
	_this->value-=*_n;
}

void NumberZs_xorset(ScriptEngine *_se, Number *_this,Number *_n){
	_this->value-=_n->value;
}
----

Next, each function _NumberZs_xorset_ is registered as member metamethod __xorset_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerMemberFunction<Number>("_xorset",static_cast<void (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_xorset));

	_se->registerMemberFunction<Number>("_xorset",static_cast<void (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_xorset));
	//...

}
----

Finally, the following code it shows an example of a script that perform bitwise XOR and assignment from a _Float_ value and _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_xorset.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_xorset_out.txt[]
----

<<<

====== _shrset()

Implements _bitwise shift right assignment_ operator (aka &gt;&gt;= ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_shrset(ScriptEngine *_se, RegisteredType *_this,ParamType *_value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : Value or variable as right operand. Its type can be a pointer of one defined in xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions that performs a bitwise shift right and assignment to the current instance from a _Float_ value or _Number_ type respectively,

[source,cpp]
----

void NumberZs_shrset(ScriptEngine *_se, Number *_this,zs_float *_n){
	_this->value-=*_n;
}

void NumberZs_shrset(ScriptEngine *_se, Number *_this,Number *_n){
	_this->value-=_n->value;
}
----

Next, each function _NumberZs_shrset_ is registered as member metamethod __shrset_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerMemberFunction<Number>("_shrset",static_cast<void (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_shrset));

	_se->registerMemberFunction<Number>("_shrset",static_cast<void (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_shrset));
	//...

}
----

Finally, the following code it shows an example of a script that perform bitwise shift right and assignment from a _Float_ value and _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_shrset.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_shrset_out.txt[]
----

<<<

====== _shlset()

Implements _bitwise shift left assignment_ operator (aka &lt;&lt;= ) with a value entered by parameter as right operand.

*Syntax*

[source,cpp]
----
void RegisteredType_shlset(ScriptEngine *_se, RegisteredType *_this,ParamType *_value);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance
- __value_ : Value or variable as right operand. Its type can be a pointer of one defined in xref:api_types#_types[primitive types] or a pointer of other xref:api_expose_cpp_types#_register_a_type[registered type].

[.underline]#Returns#

None.

*Example*

The following code defines two functions that performs a bitwise shift right and assignment to the current instance from a _Float_ value or _Number_ type respectively,

[source,cpp]
----

void NumberZs_shlset(ScriptEngine *_se, Number *_this,zs_float *_n){
	_this->value-=*_n;
}

void NumberZs_shlset(ScriptEngine *_se, Number *_this,Number *_n){
	_this->value-=_n->value;
}
----

Next, each function _NumberZs_shlset_ is registered as member metamethod __shlset_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerMemberFunction<Number>("_shlset",static_cast<void (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_shlset));

	_se->registerMemberFunction<Number>("_shlset",static_cast<void (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_shlset));
	//...

}
----

Finally, the following code it shows an example of a script that perform bitwise shift right and assignment from a _Float_ value and _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_shlset.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_shlset_out.txt[]
----

<<<

====== _not()

Implements _not_ pre operator (aka !)  

*Syntax*

[source,javascript]
----
bool RegisteredType_not(ScriptEngine *_se, RegisteredType *_this);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance

[.underline]#Returns#

A boolean value as a result of not operation

*Example*

The following code defines a function as a _not_ operation as true when current instance has a value of 0,

[source,cpp]
----

bool NumberZs_not(ScriptEngine *_se,Number *_this){
	return _this->value == 0;
}

----

Next, the function _NumberZs_not_ is registered as member metamethod __not_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){

	//...

	_se->registerMemberFunction<Number>("_not",&NumberZs_not);

	//...

}
----

Finally, the following code it shows an example of a script that evaluates not condition of a _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_not.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_not_out.txt[]
----

<<<

====== _neg()

Implements _negate_ pre operator (aka -a ) 

*Syntax*

[source,javascript]
----
ClassObject *RegisteredType_neg(ScriptEngine *_se, RegisteredType *_this);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance

[.underline]#Returns#

An object with its negated value

*Example*

The following code defines a function as a _neg_ operation by returning a new _Number_ instance with the negate value of current instance,

[source,cpp]
----

Number * NumberZs_neg(ScriptEngine *_se,Number *_this){
	return new Number(-_this->value);
}

----

Next, the function _NumberZs_neg_ is registered as member metamethod __neg_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){

	//...

	_se->registerMemberFunction<Number>("_neg",&NumberZs_neg);

	//...

}
----

Finally, the following code it shows an example of a script that returns the negate of a _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_neg.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_neg_out.txt[]
----

<<<

====== _postinc()

Implements _post increment_ operator (aka a++ ) 

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_postinc(ScriptEngine *_se, RegisteredType *_this);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance

[.underline]#Returns#

Return new type wrapped in xref:chapter_4_annex_api_types.adoc#_classscriptobject[ClassScripObject] with the value before perform post increment operation


*Example*

The following code defines a function as a _postinc_ operation that increments the value of current instance and returns the object with the value before _postinc_ operation,

[source,cpp]
----

ClassObject *  NumberZs_postinc(ScriptEngine *_se,Number *_this){
	return _se->newClassObject(new Number(_this->value++));
}

----

Next, the function _NumberZs_postinc_ is registered as member metamethod __postinc_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){

	//...

	_se->registerMemberFunction<Number>("_postinc",NumberZs_postinc);

	//...

}
----

Finally, the following code it shows an example of a script that performs a post increment operation of a _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_postinc.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_postinc_out.txt[]
----

<<<

====== _postdec()

Implements _post decrement_ operator (aka a++ ) 

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_postdec(ScriptEngine *_se, RegisteredType *_this);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance

[.underline]#Returns#

Return new type wrapped in xref:chapter_4_annex_api_types.adoc#_classscriptobject[ClassScripObject] with the value before perform post decrement operation


*Example*

The following code defines a function as a _postdec_ operation that decrements the value of current instance and returns the object with the value before _postdec_ operation,

[source,cpp]
----

ClassObject * NumberZs_postdec(ScriptEngine *_se,Number *_this){
	return _se->newClassObject(new Number(_this->value--));
}

----

Next, the function _NumberZs_postdec_ is registered as member metamethod __postdec_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){

	//...

	_se->registerMemberFunction<Number>("_postdec",NumberZs_postdec);

	//...

}
----

Finally, the following code it shows an example of a script that performs a post decrement operation of a _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_postdec.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_postdec_out.txt[]
----

<<<

====== _preinc()

Implements _pre increment_ operator (aka ++a ) 

*Syntax*

[source,javascript]
----
ClassObject *RegisteredType_preinc(ScriptEngine *_se, RegisteredType *_this);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance

[.underline]#Returns#

Return new type wrapped in xref:chapter_4_annex_api_types.adoc#_classscriptobject[ClassScripObject] with the value after perform post increment operation

*Example*

The following code defines a function as a _preinc_ operation that pre increments the value of current instance and returns the object with the value before _preinc_ operation,

[source,cpp]
----

ClassObject * NumberZs_preinc(ScriptEngine *_se,Number *_this){
	return _se->newClassObject(new Number(++_this->value));
}

----

Next, the function _NumberZs_preinc_ is registered as member metamethod __preinc_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){

	//...

	_se->registerMemberFunction<Number>("_preinc",NumberZs_preinc);

	//...

}
----

Finally, the following code it shows an example of a script that performs a pre increment operation of a _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_preinc.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_preinc_out.txt[]
----

<<<

====== _predec()

Implements _pre decrement_ operator (aka --a ) 

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_predec(ScriptEngine *_se, RegisteredType *_this);
----

[.underline]#Parameters#

- __zs_ : ScriptEngine context
- __this_ : The current instance

[.underline]#Returns#

Return new type wrapped in xref:chapter_4_annex_api_types.adoc#_classscriptobject[ClassScripObject] with the value after perform post increment operation

*Example*

The following code defines a function as a _predec_ operation that pre decrements the value of current instance and returns the object with the value before _predec_ operation,


[source,cpp]
----

ClassObject  *NumberZs_predec(ScriptEngine *_se,Number *_this){
	return _se->newClassObject(new Number(--_this->value));
}

----

Next, the function _NumberZs_predec_ is registered as member metamethod __predec_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){

	//...

	_se->registerMemberFunction<Number>("_predec",NumberZs_predec);

	//...

}
----

Finally, the following code it shows an example of a script that performs a pre decrement operation of a _Number_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_predec.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_predec_out.txt[]
----

<<<

====== _in()

Implements _in_ operator 

*Syntax*

[source,javascript]
----

bool RegisteredType_in(zetscript::ScriptEngine *_se, Data *_this, zs_float *_value);

----

[.underline]#Parameters#

- __value_ : Value or variable as value to check whether exist or not in the containing class

[.underline]#Returns#

Boolean telling whether the __value_ exist in or not.

*Example*

Let's define type Data as,

[source,cpp]
----

class Data{
public:
	std::vector<float> data;
	Data(){
		this->data={0,1,1,10,3,4,6};
	} 
};

----


The following code defines a function as a _in_ operation by searching a value in the vector of current instance of _Data_ type,

[source,cpp]
----

bool DataZs_in(zetscript::ScriptEngine *_se, Data *_this, zs_float *_value){
	for(auto d : _this->data){
		if(d == *_value){
			return true;;
		}
	}
	return false;
}

----

The following code shows an example of registering functions and a script that performs a _in_ operation of a _Data_ object.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_in.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_in_out.txt[]
----

<<<

===== Static metamethods

====== _equ()

Implements _equal_ operator (aka == ) between first operand and second operand

*Syntax*

[source,javascript]
----
bool RegisteredType_equ(RegisteredType *_op1, RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- True if op1 and op2 are EQUAL
- False if op1 and op2 are NOT EQUAL

*Example*

The following code defines three functions that performs _equ_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

bool  NumberZs_equ(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _n1->value ==_n2->value;
}

bool  NumberZs_equ(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _n1->value == *_n2;
}

bool NumberZs_equ(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return *_n1 == _n2->value;
}
----

Next, each function _NumberZs_equ_ is registered as member metamethod __equ_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerStaticMemberFunction<Number>("_equ",static_cast<bool (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_equ));
	_se->registerStaticMemberFunction<Number>("_equ",static_cast<bool (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_equ));
	_se->registerStaticMemberFunction<Number>("_equ",static_cast<bool (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_equ));
	//...
}
----

Finally, the following code it shows an example of a script that performs _equ_ operation from a _Float_ and _Number_.

[source,cpp]
----
include::../examples/api/register_type/register_member_metamethod_equ.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_equ_out.txt[]
----

<<<

====== _nequ()

Implements _not equal_ operator (aka != ) between first operand and second operand

*Syntax*

[source,javascript]
----
bool RegisteredType_nequ(RegisteredType *_op1, RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- True if op1 and op2 are NOT EQUAL
- False if op1 and op2 are EQUAL

*Example*

The following code defines three functions that performs _equ_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

bool  NumberZs_nequ(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _n1->value !=_n2->value;
}

bool  NumberZs_nequ(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _n1->value != *_n2;
}

bool NumberZs_nequ(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return *_n1 != _n2->value;
}
----

Next, each function _NumberZs_nequ_ is registered as member metamethod __nequ_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){

	//...

	_se->registerStaticMemberFunction<Number>("_nequ",static_cast<bool (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_nequ));
	_se->registerStaticMemberFunction<Number>("_nequ",static_cast<bool (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_nequ));
	_se->registerStaticMemberFunction<Number>("_nequ",static_cast<bool (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_nequ));

	//...

}
----

Finally, the following code it shows an example of a script that performs _nequ_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_nequ.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_nequ_out.txt[]
----

<<<

====== _lt()

Implements _less than_ operator (aka < ) between first operand and second operand

*Syntax*

[source,javascript]
----
bool RegisteredType_lt(RegisteredType *_op1, RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- True if op1 is LESS THAN op2
- False if op1 is GRATHER EQUAL THAN op2

*Example*

The following code defines three functions that performs _lt_ operation from _Float_ value or _Number_ type,

[source,cpp]
----
bool  NumberZs_lt(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _n1->value <_n2->value;
}

bool  NumberZs_lt(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _n1->value < *_n2;
}

bool NumberZs_lt(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return *_n1 < _n2->value;
}
----

Next, each function _NumberZs_lt_ is registered as member metamethod __lt__ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerStaticMemberFunction<Number>("_lt",static_cast<bool (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_lt));
	_se->registerStaticMemberFunction<Number>("_lt",static_cast<bool (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_lt));
	_se->registerStaticMemberFunction<Number>("_lt",static_cast<bool (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_lt));
	//...
}
----

Finally, the following code it shows an example of a script that performs _lt_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_lt.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_lt_out.txt[]
----

<<<

====== _lte()

Implements _less than or equal_ operator (aka \<= ) between first operand and second operand

*Syntax*

[source,javascript]
----
_lte(_op1,_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- True if op1 is LESS THAN OR EQUAL op2
- False if op1 is GRATHER THAN op2

*Example*

The following code defines three functions that performs _lte_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

bool  NumberZs_lte(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _n1->value <=_n2->value;
}

bool  NumberZs_lte(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _n1->value <= *_n2;
}

bool NumberZs_lte(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return *_n1 <= _n2->value;
}
----

Next, each function _NumberZs_lte_ is registered as member metamethod __lte_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerStaticMemberFunction<Number>("_lte",static_cast<bool (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_lte));
	_se->registerStaticMemberFunction<Number>("_lte",static_cast<bool (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_lte));
	_se->registerStaticMemberFunction<Number>("_lte",static_cast<bool (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_lte));
	//...
}
----

Finally, the following code it shows an example of a script that performs _lte_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_lte.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_lte_out.txt[]
----

<<<

====== _gt()

Implements _greather than_ operator (aka > ) between first operand and second operand

*Syntax*

[source,javascript]
----
bool RegisteredType_gt(RegisteredType *_op1, RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- True if op1 is GREATHER THAN op2
- False if op1 is LESS OR EQUAL THAN op2

*Example*

The following code defines three functions that performs _gt_ operation from _Float_ value or _Number_ type,

[source,cpp]
----
bool  NumberZs_gt(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _n1->value >_n2->value;
}

bool  NumberZs_gt(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _n1->value > *_n2;
}

bool NumberZs_gt(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return *_n1 > _n2->value;
}
----

Next, each function _NumberZs_gt_ is registered as member metamethod __gt__ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...

	_se->registerStaticMemberFunction<Number>("_gt",static_cast<bool (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_gt));
	_se->registerStaticMemberFunction<Number>("_gt",static_cast<bool (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_gt));
	_se->registerStaticMemberFunction<Number>("_gt",static_cast<bool (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_gt));

	//...

}
----

Finally, the following code it shows an example of a script that performs __gt__ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_gt.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_gt_out.txt[]
----

<<<

====== _gte()

Implements _greather than or equal_ operator (aka &gt;= ) between first operand and second operand

*Syntax*

[source,javascript]
----
bool RegisteredType_gte(RegisteredType *_op1, RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- True if op1 is GREATHER THAN OR EQUAL op2
- False if op1 is LESS THAN op2

*Example*

The following code defines three functions that performs _equ_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

bool  NumberZs_gte(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _n1->value >=_n2->value;
}

bool  NumberZs_gte(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _n1->value >= *_n2;
}

bool NumberZs_gte(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return *_n1 >= _n2->value;
}
----

Next, each function _NumberZs_gte_ is registered as member metamethod __gte_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerMemberConstructor<Number>(static_cast<void (*)(zetscript::ScriptEngine *_se,Number *_this, zetscript::zs_float *_value)>(&NumberZs_set));

	_se->registerMemberConstructor<Number>(static_cast<void (*)(zetscript::ScriptEngine *_se,Number *_this, Number *_value)>(&NumberZs_set));
	//...

}
----

Finally, the following code it shows an example of a script that performs _gte_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_gte.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_gte_out.txt[]
----

<<<

====== _add()

Implements _add_ operator (aka + ) between first operand and second operand

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_add(RegisteredType *_op1,RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- A new object as a result of add operation 

*Example*

The following code defines three functions that performs _add_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

ClassObject * NumberZs_add(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _se->newClassObject(new Number(_n1->value +_n2->value));
}

ClassObject * NumberZs_add(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _se->newClassObject(new Number(_n1->value + *_n2));
}

ClassObject * NumberZs_add(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return _se->newClassObject(new Number(*_n1 + _n2->value));
}

----

Next, each function _NumberZs_add_ is registered as member metamethod __add_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){
	//...

	_se->registerStaticMemberFunction<Number>("_add",static_cast<ClassObject * (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_add));
	_se->registerStaticMemberFunction<Number>("_add",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_add));
	_se->registerStaticMemberFunction<Number>("_add",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_add));

	//...
}
----

Finally, the following code it shows an example of a script that performs __add_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_add.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_add_out.txt[]
----

<<<

====== _sub()

Implements _subtraction_ operator (aka - ) between first operand and second operand

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_sub(RegisteredType *_op1,RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- A new object as a result of add operation 

*Example*

The following code defines three functions that performs _sub_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

ClassObject * NumberZs_sub(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _se->newClassObject(new Number(_n1->value +_n2->value));
}

ClassObject * NumberZs_sub(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _se->newClassObject(new Number(_n1->value + *_n2));
}

ClassObject * NumberZs_sub(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return _se->newClassObject(new Number(*_n1 + _n2->value));
}

----

Next, each function _NumberZs_sub_ is registered as member metamethod __sub_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){
	//...

	_se->registerStaticMemberFunction<Number>("_sub",static_cast<ClassObject * (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_sub));
	_se->registerStaticMemberFunction<Number>("_sub",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_sub));
	_se->registerStaticMemberFunction<Number>("_sub",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_sub));

	//...
}
----

Finally, the following code it shows an example of a script that performs __sub_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_sub.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_sub_out.txt[]
----

<<<

====== _mul()

Implements _multiplication_ operator (aka * ) between first operand and second operand

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_mul(RegisteredType *_op1,RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- A new object as a result of multiplication operation 

*Example*

The following code defines three functions that performs _mul_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

ClassObject * NumberZs_mul(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _se->newClassObject(new Number(_n1->value * _n2->value));
}

ClassObject * NumberZs_mul(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _se->newClassObject(new Number(_n1->value * (*_n2)));
}

ClassObject * NumberZs_mul(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return _se->newClassObject(new Number(*_n1 * _n2->value));
}

----

Next, each function _NumberZs_mul_ is registered as member metamethod __mul_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerStaticMemberFunction<Number>("_mul",static_cast<ClassObject * (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_mul));
	_se->registerStaticMemberFunction<Number>("_mul",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_mul));
	_se->registerStaticMemberFunction<Number>("_mul",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_mul));
	//...
}
----

Finally, the following code it shows an example of a script that performs __mul__ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_mul.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_mul_out.txt[]
----

<<<

====== _div()

Implements _division_ operator (aka / ) between first operand and second operand

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_div(RegisteredType *_op1,RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- A new object as a result of division operation 

*Example*

The following code defines three functions that performs _div_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

ClassObject * NumberZs_div(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _se->newClassObject(new Number(_n1->value / _n2->value));
}

ClassObject * NumberZs_div(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _se->newClassObject(new Number(_n1->value / *_n2));
}

ClassObject * NumberZs_div(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return _se->newClassObject(new Number(*_n1 / _n2->value));
}
----

Next, each function _NumberZs_div_ is registered as member metamethod __div_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){

	//...
	_se->registerStaticMemberFunction<Number>("_div",static_cast<ClassObject * (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_div));
	_se->registerStaticMemberFunction<Number>("_div",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_div));
	_se->registerStaticMemberFunction<Number>("_div",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_div));
	//...
}
----

Finally, the following code it shows an example of a script that performs __div_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_div.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_div_out.txt[]
----

<<<

====== _mod()

Implements _modulus_ operator (aka % ) between first operand and second operand

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_mod(RegisteredType *_op1,RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- A new object as a result of modulus operation 

*Example*

The following code defines three functions that performs _mod_ operation from _Float_ value or _Number_ type,

[source,cpp]
----
ClassObject * NumberZs_mod(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _se->newClassObject(new Number(fmod(_n1->value,_n2->value)));
}

ClassObject * NumberZs_mod(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _se->newClassObject(new Number(fmod(_n1->value, *_n2)));
}

ClassObject * NumberZs_mod(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return _se->newClassObject(new Number(fmod(*_n1, _n2->value)));
}
----

Next, each function _NumberZs_mod_ is registered as member metamethod __mod_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerStaticMemberFunction<Number>("_mod",static_cast<ClassObject * (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_mod));
	_se->registerStaticMemberFunction<Number>("_mod",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_mod));
	_se->registerStaticMemberFunction<Number>("_mod",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_mod));
	//...
}
----

Finally, the following code it shows an example of a script that performs __mod_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_mod.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_mod_out.txt[]
----

<<<

====== _and()

Implements _bitwise AND_ operator (aka & ) between first operand and second operand

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_and(RegisteredType *_op1,RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- A new object as a result of bitwise AND operation 

*Example*

The following code defines three functions that performs _AND_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

ClassObject * NumberZs_and(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _se->newClassObject(new Number((zs_int)_n1->value & (zs_int)_n2->value));
}

ClassObject * NumberZs_and(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _se->newClassObject(new Number((zs_int)_n1->value & (zs_int)*_n2));
}

ClassObject * NumberZs_and(ScriptEngine *_se,zs_float *_n1, Number * _n2){
	return _se->newClassObject(new Number((zs_int)*_n1 & (zs_int)_n2->value));
}
----

Next, each function _NumberZs_and_ is registered as member metamethod __AND_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----
void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerStaticMemberFunction<Number>("_and",static_cast<ClassObject * (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_and));
	_se->registerStaticMemberFunction<Number>("_and",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_and));
	_se->registerStaticMemberFunction<Number>("_and",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_and));
	//...
}
----

Finally, the following code it shows an example of a script that performs __AND_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_and.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_and_out.txt[]
----

<<<

====== _or()

Implements _bitwise OR_ operator (aka | ) between first operand and second operand

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_or(RegisteredType *_op1,RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- A new object as a result of bitwise OR operation 

*Example*

The following code defines three functions that performs _OR_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

ClassObject * NumberZs_or(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _se->newClassObject(new Number((zs_int)_n1->value | (zs_int)_n2->value));
}

ClassObject * NumberZs_or(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _se->newClassObject(new Number((zs_int)_n1->value | (zs_int)*_n2));
}

ClassObject * NumberZs_or(ScriptEngine *_se,zs_float *_n1, Number * _n2){
	return _se->newClassObject(new Number((zs_int)*_n1 | (zs_int)_n2->value));
}

----

Next, each function _NumberZs_or_ is registered as member metamethod __OR_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerStaticMemberFunction<Number>("_or",static_cast<ClassObject * (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_or));
	_se->registerStaticMemberFunction<Number>("_or",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_or));
	_se->registerStaticMemberFunction<Number>("_or",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_or));
	//...
}
----

Finally, the following code it shows an example of a script that performs __OR_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_or.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_or_out.txt[]
----

<<<

====== _xor()

Implements _bitwise XOR_ operator (aka ^ ) between first operand and second operand

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_xor(RegisteredType *_op1,RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- A new object as a result of bitwise XOR operation 

*Example*

The following code defines three functions that performs _XOR_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

ClassObject * NumberZs_xor(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _se->newClassObject(new Number((zs_int)_n1->value ^ (zs_int)_n2->value));
}

ClassObject * NumberZs_xor(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _se->newClassObject(new Number((zs_int)_n1->value ^ (zs_int)*_n2));
}

ClassObject * NumberZs_xor(ScriptEngine *_se,zs_float *_n1, Number * _n2){
	return _se->newClassObject(new Number((zs_int)*_n1 ^ (zs_int)_n2->value));
}

----

Next, each function _NumberZs_xor_ is registered as member metamethod __XOR_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerStaticMemberFunction<Number>("_xor",static_cast<ClassObject * (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_xor));
	_se->registerStaticMemberFunction<Number>("_xor",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_xor));
	_se->registerStaticMemberFunction<Number>("_xor",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_xor));
	//...
}
----

Finally, the following code it shows an example of a script that performs __XOR_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_xor.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_xor_out.txt[]
----

<<<

====== _shl()

Implements _bitwise shift left_ operator (aka << ) between first operand and second operand

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_shl(RegisteredType *_op1,RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- A new object as a result of bitwise SHIFT LEFT operation 

*Example*

[source,cpp]
----

//...

ClassObject * NumberZs_shl(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _se->newClassObject(new Number((zs_int)_n1->value << (zs_int)_n2->value));
}

ClassObject * NumberZs_shl(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _se->newClassObject(new Number((zs_int)_n1->value << (zs_int)*_n2));
}

ClassObject * NumberZs_shl(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return _se->newClassObject(new Number((zs_int)*_n1 << (zs_int)_n2->value));
}

----

Next, each function _NumberZs_shl_ is registered as member metamethod __shl_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerStaticMemberFunction<Number>("_shl",static_cast<ClassObject * (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_shl));
	_se->registerStaticMemberFunction<Number>("_shl",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,zs_float *)>(&NumberZs_shl));
	_se->registerStaticMemberFunction<Number>("_shl",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_shl));
	//...
}
----

Finally, the following code it shows an example of a script that performs __shl_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_shl.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_shl_out.txt[]
----

<<<

====== _shr()

Implements _bitwise SHIFT RIGHT_ operator (aka << ) between first operand and second operand

*Syntax*

[source,javascript]
----
ClassObject * RegisteredType_shr(RegisteredType *_op1,RegisteredType *_op2)
----

[.underline]#Parameters#

- __op1_ : 1st operand.
- __op2_ : 2nd operand.

[.underline]#Returns#

- A new object as a result of bitwise SHIFT RIGHT operation 

*Example*

The following code defines three functions that performs _shr_ operation from _Float_ value or _Number_ type,

[source,cpp]
----

ClassObject * NumberZs_shr(ScriptEngine *_se,Number *_n1, Number *_n2){
	return _se->newClassObject(new Number((zs_int)_n1->value >> (zs_int)_n2->value));
}

ClassObject * NumberZs_shr(ScriptEngine *_se,Number *_n1, zs_float *_n2){
	return _se->newClassObject(new Number((zs_int)_n1->value >> (zs_int)*_n2));
}

ClassObject * NumberZs_shr(ScriptEngine *_se,zs_float *_n1, Number *_n2){
	return _se->newClassObject(new Number((zs_int)*_n1 >> (zs_int)_n2->value));
}

----

Next, each function _NumberZs_shr_ is registered as member metamethod __shr_ through _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(zetscript::ScriptEngine *_se){
	//...
	_se->registerStaticMemberFunction<Number>("_shr",static_cast<ClassObject * (*)(ScriptEngine *_se,zs_float *,Number * )>(&NumberZs_shr));
	_se->registerStaticMemberFunction<Number>("_shr",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,zs_float * )>(&NumberZs_shr));
	_se->registerStaticMemberFunction<Number>("_shr",static_cast<ClassObject * (*)(ScriptEngine *_se,Number *,Number * )>(&NumberZs_shr));
	//...
}
----

Finally, the following code it shows an example of a script that performs __shr_ operation from a _Float_ and _Number_.

[source,javascript]
----
include::../examples/api/register_type/register_member_metamethod_shr.cpp[]
----

Console output:

[source,text]
----
include::../examples/api/register_type/register_member_metamethod_shr_out.txt[]
----
