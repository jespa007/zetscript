<<<
=== Exposing C++ types to ZetScript

In this chapter will see how to to register C&#43;&#43; types, function members, metamethods and properties in order to be exposed in ZetScript.

==== Register a type

There's two ways to register a type,

- Register a non instantiable type 
- Register an instantiable type

===== Register a type as non instantiable

Register a non instantiable type it means that it *CANNOT* create or instantiate new objects of that _type_ in ZetScript using the _new_ operator, so the object only can be acceded by reference returned by some registered function. This kind of register is useful when it wants to have a control of instantiated objects in the native application.

To register a non instantible type it's done calling _ScriptEngine::registerType_ specifying the type in the template and passing the class name by parameter.

*Syntax*
[source,cpp]
----
Type * registerType<T>(const String & _class_name);
----

[.underline]#Template# 

- T: C&#43;&#43; struct/class type

[.underline]#Parameters# 

- _class_name: Class name that will be referenced in ZetScript

[.underline]#Returns# 

A _ScriptType_ object

*Example*

Let's define a 'Number' type in the file called 'Number.h',

[source,cpp]
----
include::../examples/api/register_type/Number.h[]
----

<<<

The code below it registers _Number_ type as non instantiable,

[source,cpp]
----

#include "Number.h"
#include "zetscript.h"

using zetscript::ScriptEngine;

int main()
{
	ScriptEngine script_engine;

	script_engine.registerType<Number>("Number");
	 	
 	// ...
 }
}
----

Now, let's suppose we want to instantiate a _Number_ type by evaluating the following script code,

[source,cpp]
----
	// It throws an error that 'Number' is not instantiable
 	script_engine.compileAndRun(
 		"var number= new Number();"
 	);
----

The evaluation will fail with the following output,

 'Number' type is not instantiable


The only way to operate with a 'Number' object non instantiable is by a reference returned by a registered function as it shows in the following example,


[source,cpp]
----
include::../examples/api/register_type/register_non_instantiable_type.cpp[]
----

<<<

===== Register a type as instantiable

Register an instantiable type it means that it *CAN* instantiate objects of that 'type' in ZetScript code using operator _new_.

To register instantiable type its done by passing two c functions as to create and destroy native type.

*Syntax*
[source,cpp]
----
Type * registerType<_Type>(const String & _class_name, RegisteredType * (*_new_native_instance)(ScriptEngine *_script_engine), void (*_delete_native_instance)(ScriptEngine *_script_engine, RegisteredType * _this));
----

[.underline]#Template# 

- __Type_: The struct/class to register.

[.underline]#Parameters# 

- __class_name_: The class name.
- __new_native_instance_: A C function that creates an returns a new instance. This function has the following signature,

[source,cpp]
----
RegsiteredType * RegisteredType_new(ScriptEngine *_script_engine);
----

- __delete_native_instance_: A C function that deletes native instance. The SECOND parameter it must define the current instance,

[source,cpp]
----
void RegisteredType_delete(ScriptEngine *_script_engine, RegisteredType *_this);
----

[.underline]#Returns# 

A _Type_ object

*Example*

Following the example of the _Number_ type and in order to compact the lines of code for the next examples of this section, it has been proposed put all registering and declaration code of all functions in a file called _NumberZs.h_. Inside _NumberZs.h_ there's a main function called  _NumberZs_register_ that will register all  those functions.

Let's define _NumberZs_new_ and _NumberZs_delete_ functions that creates and destroys a _Number_ type instantiation respectively,

[source,cpp]
----
Number *NumberZs_new(ScriptEngine *_script_engine){
	return new Number();
}

void NumberZs_delete(ScriptEngine *_script_engine,Number *_this){
	delete _this;
}
----

Then, in the _NumberZs_register_ function, it registers _Number_ type as instantiable by passing  _NumberZs_new_ and _NumberZs_delete_ functions,


[source,cpp]
----
void NumberZs_register(ScriptEngine *_script_engine){

	_script_engine->registerType<Number>("Number",NumberZs_new,NumberZs_delete);

}
----

Finally, the following code shows an example of instantiation of a _Number_ type,


[source,cpp]
----
include::../examples/api/register_type/register_instantiable_type.cpp[]
----

===== Register a constructor


To register a constructor function it has to create and register a C&#43;&#43; function in section xref:api_data_types.adoc#_scriptengineregisterconstructor[ScriptEngine::registerConstructor].

*Example*

The following code defines two functions that accepts a xref:language_data_types.adoc#&lowbar;float[Float] value or _Number_ pointer type respectively,

[source,cpp]
----

//...

void NumberZs_constructor(ScriptEngine *_script_engine,Number *_this,zs_float *_value){
	_this->value=*_value;
}

void NumberZs_constructor(ScriptEngine *_script_engine,Number *_this,Number *_value){
	_this->value=_value->value;
}
----

Next, the functions _NumberZs_constructor_ are registered with _ScriptEngine::registerConstructor_ method,

[source,cpp]
----


void NumberZs_register(ScriptEngine *_script_engine){

	//...

	_script_engine->registerConstructor<Number>(static_cast<void (*)(ScriptEngine *_script_engine,Number *_this, zs_float *_value)>(&NumberZs_constructor));

	_script_engine->registerConstructor<Number>(static_cast<void (*)(ScriptEngine *_script_engine,Number *_this, Number *_value)>(&NumberZs_constructor));

	//...

}
----

Finally, the following code it shows an example of a script that creates an object _Number_ type passing a float value on its constructor,


[source,cpp]
----
include::../examples/api/register_type/register_instantiable_type_with_constructor.cpp[]
----

<<<

==== Register members

===== Register member function

To register a member function it has to create and register a C function explained in section xref:api_data_types.adoc#_scriptengineregistermemberfunction[ScriptEngine::registerMemberFunction].

*Example*


The following code defines a function that returns a xref:language_data_types.adoc#&lowbar;integer[Integer] ,

[source,cpp]
----
zs_int NumberZs_toInteger(ScriptEngine *_script_engine,Number *_this){
	return _this->value;
}
----

Next, it registers _NumberZs_toInteger_ as member function named _toInteger_ through with _ScriptEngine::registerMemberFunction_,

[source,cpp]
----

void NumberZs_register(ScriptEngine *_script_engine){

	//...

	_script_engine->registerMemberFunction<Number>("toInteger",&NumberZs_toInteger);

	//...

}
----

<<<

Finally, the following code it shows an example of a script that calls member function _Number::toInteger()_ after create object _Number_ type,

[source,cpp]
----
include::../examples/api/register_type/register_member_function.cpp[]
----

The ouput is the following,

[source,txt]
----
include::../examples/api/register_type/register_member_function_out.txt[]
----

===== Register static member function

To register a static member function it has to create and register a C function explained in section xref:api_data_types.adoc#_scriptengineregisterstaticmemberfunction[ScriptEngine::registerStaticMemberFunction].


*Example*

The following code defines a function _NumberZs_pow_ that takes two arguments and, returns the power raised to the base number,

[source,cpp]
----

//...

zs_float NumberZs_pow(ScriptEngine *_script_engine,zs_float *_base, zs_float * _power){
	return (*_base) * (*_power);
}

----

Next, it registers _NumberZs_pow_ as static member function named _pow_ through with _ScriptEngine::registerStaticMemberFunction_,

[source,cpp]
----

void NumberZs_register(ScriptEngine *_script_engine){

	//...

	_script_engine->registerStaticMemberFunction<Number>("pow",&NumberZs_pow);

	//...

}
----

Finally, the following code it shows an example of a script that calls static member function _Number::pow()_,

[source,cpp]
----
include::../examples/api/register_type/register_static_member_function.cpp[]
----

The ouput is the following,

[source,txt]
----
include::../examples/api/register_type/register_static_member_function_out.txt[]
----

==== Inheritance

To register a type and tell that is base of other type is done through xref:api_data_types#_scriptengineextends[ScriptEngine::extends].


*Example*

In this example it shows an example the the registered type _MyCppTypeExtend_ is extended from registered type _MyCppType_,

[source,cpp]
----
include::../examples/api/register_type/register_type_inheritance.cpp[]
----

Console output,

[source,txt]
----
include::../examples/api/register_type/register_type_inheritance_out.txt[]
----

<<<

A ZetScript script class can be extended from any registered type. In the following evaluates an script that a script class called _ScriptMyCppTypeExtend_ extends from registered type _MyCppTypeExtend_,

[source,javascript]
----

int main(){

	// ...

	script_engine.compileAndRun(
		"class ScriptMyCppTypeExtend extends MyCppTypeExtend{\n"
		"	function1(_arg1){\n"
		"		Console::outln("script argument is "+_arg1);\n"
		"		super(this.data1+arg1); // calls function1\n"
		"	}\n"
		"};\n"
		"var MyCppType=new ScriptMyCppTypeExtend(10);\n"
		"MyCppType.function1(5);\n"
	);
	
	return 0;
}

----

Console output,

[source,text]
----
include::../examples/api/register_type/register_type_script_class_extends_from_registered_type_out.txt[]
----

include::api_expose_cpp_type_metamethods.adoc[]
include::api_expose_cpp_type_properties.adoc[]