:highlightjs-languages: cpp, javascript
:sectnums:


//  Summary: 
// 1. eval
// eval expression
// eval file
// eval options
// Explain builtin types and its functions
// 1. Calling script functions from c++
//  1.1 bind script function 
//  1.2 bind member function from instanced global object
//  1.3 Life time objects returned
//      zs_int,zs_float,bool
//      other times should bee freed. Show error if not freed
// 2. Calling c++ function from script
// 2.1 Explain function passing these type IN parameters
//    Boolean --> bool *
//    Integer --> zs_int or zs_int *
//	  Float  --> zs_float * 
//	  String  --> StringScriptObject * (and how acces/modify its elements)
//	  Array  --> ArrayScriptObject *  (and how acces/modify its elements)
//	  Object  --> ObjectScriptObject *  (and how acces/modify its elements)
//    class --> class (see seccion 4 for more information)
//    Calling script functions (callbacks). Process registerFunction and call-it
// 2.2 Returning variables
//    Boolean --> bool
//    Integer --> zs_int
//	  Float  --> zs_float
//	  String  --> zs->newStringScriptObject  (and how add elements)
//	  Array  --> zs->newArrayScriptObject  (and how add elements)
//	  Object  --> zs->newObjectScriptObject  (and how add elements)
//    class --> zs->newClass<class> (see seccion 4 for more information)
// 3. BindTypes
//    Show all examples with type "Number"!!!!
//	  no-instantiable types
//	  instantiable types
//    bindFunctionsMember
//    bindPropertyMember through its metamethods



== the API

=== Eval

ZetScript can evaluate scripts from string or from file

*Eval from string*

[source,c++]
----
include::../examples/the_api/eval/eval_string.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/eval/eval_string_out.txt[]
----


*Eval from file*

Having the following script file called `file.zs` with the following content,
[source,javascript]
----
include::../examples/the_api/eval/file.zs[]
----

Out:

At the c++ side, to eval `file.zs` file it's done through _evalFile_ function as it shows as it follows,

[source,c++]
----
include::../examples/the_api/eval/eval_file.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/eval/eval_file_out.txt[]
----


==== Eval options

===== EVAL_OPTION_NO_EXECUTE

In order to eval script but no execute add `EVAL_OPTION_NO_EXECUTE` option

[source,c++]
----
include::../examples/the_api/eval/eval_file_option_no_execute.cpp[]
----


===== EVAL_OPTION_PRINT_BYTE_CODE

In order to show byte code for a script add `EVAL_OPTION_PRINT_BYTE_CODE` option

[source,c++]
----
include::../examples/the_api/eval/eval_file_option_print_byte_code.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/eval/eval_file_option_print_byte_code_out.txt[]
----

As we can see in the output `EVAL_OPTION_PRINT_BYTE_CODE` option prints the byte code per each function. At the begin it prints summary,

 - *Function*: Function name
 - *Stack code*: Stack required for code
 - *Stack local vars*: Stack required for local variables
 - *Total stack required*: Total stack required
 - *Scopes*: Total scopes

Apart there's a description per instruction with the following columns,

- *NUM*: Instruction number
- *RS*: Required Stack for current instruction
- *AS*: Acumulated Stack in the current instruction
- *INSTRUCTION*: Byte code and operands if it needs

To know more about the meaning of byte codes see section <<Byte codes>>



include::chapter_3_the_api_call_cpp_from_zetscript.adoc[]
include::chapter_3_the_api_call_zetscript_from_cpp.adoc[]
include::chapter_3_the_api_exposing_cpp_types_to_zetscript.adoc[]
