:source-highlighter: highlight.js
:highlightjs-languages: cpp, javascript
:sectnums:


//  Summary: 
// 1. eval
// eval expression
// eval file
// eval options
// Explain builtin types and its functions
// 1. Calling script functions from c++
//  1.1 bind script function 
//  1.2 bind member function from instanced global object
//  1.3 Life time objects returned
//      zs_int,zs_float,bool
//      other times should bee freed. Show error if not freed
// 2. Calling c++ function from script
// 2.1 Explain function passing these type IN parameters
//    Boolean --> bool *
//    Integer --> zs_int or zs_int *
//	  Float  --> zs_float * 
//	  String  --> StringScriptObject * (and how acces/modify its elements)
//	  Array  --> ArrayScriptObject *  (and how acces/modify its elements)
//	  Object  --> ObjectScriptObject *  (and how acces/modify its elements)
//    class --> class (see seccion 4 for more information)
//    Calling script functions (callbacks). Process registerFunction and call-it
// 2.2 Returning variables
//    Boolean --> bool
//    Integer --> zs_int
//	  Float  --> zs_float
//	  String  --> zs->newStringScriptObject  (and how add elements)
//	  Array  --> zs->newArrayScriptObject  (and how add elements)
//	  Object  --> zs->newObjectScriptObject  (and how add elements)
//    class --> zs->newClass<class> (see seccion 4 for more information)
// 3. BindTypes
//    Show all examples with type "Number"!!!!
//	  no-instantiable types
//	  instantiable types
//    bindFunctionsMember
//    bindPropertyMember through its metamethods



== the API

=== Eval

ZetScript can evaluate scripts from string or from file

*Eval from string*

[source,c++]
----
include::../examples/the_api/eval/eval_string.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/eval/eval_string_out.txt[]
----


*Eval from file*

Having the following script file called `file.zs` with the following content,
[source,javascript]
----
include::../examples/the_api/eval/file.zs[]
----

Out:

At the c++ side, to eval `file.zs` file it's done through _evalFile_ function as it shows as it follows,

[source,c++]
----
include::../examples/the_api/eval/eval_file.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/eval/eval_file_out.txt[]
----


==== Eval options

===== EVAL_OPTION_NO_EXECUTE

In order to eval script but no execute add `EVAL_OPTION_NO_EXECUTE` option

[source,c++]
----
include::../examples/the_api/eval/eval_file_option_no_execute.cpp[]
----


===== EVAL_OPTION_PRINT_BYTE_CODE

In order to show byte code for a script add `EVAL_OPTION_PRINT_BYTE_CODE` option

[source,c++]
----
include::../examples/the_api/eval/eval_file_option_print_byte_code.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/eval/eval_file_option_print_byte_code_out.txt[]
----

As we can see in the output `EVAL_OPTION_PRINT_BYTE_CODE` option prints the byte code per each function. At the begin it prints summary,

 - *Function*: Function name
 - *Stack code*: Stack required for code
 - *Stack local vars*: Stack required for local variables
 - *Total stack required*: Total stack required
 - *Scopes*: Total scopes

Apart there's a description per instruction with the following columns,

- *NUM*: Instruction number
- *RS*: Required Stack for current instruction
- *AS*: Acumulated Stack in the current instruction
- *INSTRUCTION*: Byte code and operands if it needs

To know more about the meaning of byte codes see section <<Byte codes>>


=== Calling native code from ZetScript

To call native code from _ZetScript_ it must create a C function with an apropiate prototype to get its arguments and return its results and finally register that function.
As the parameters, the function must always include `zetscript::ZetScript *` type as first parameter and then a maximum of 9 parameters as types in one defined in  <<Built-in types>> or other registered type. As return, the function it can return `void` (it doesn't returns any parameter) or some type defined in <<Built-in types>> or other registered type.

*Syntax*

[source,c++]
----
ReturnType zetscriptFunctionInterface(zetscript::ZetScript *_zs, ParamType _arg1, ParamType _arg2, ..., ParamType _arg9 ){
	....
}
----

Where,

- _ReturnType_: It can be `void` or some type defined in <<Built-in types>> or other registered type.
- _ParamType_: It can be one defined in  <<Built-in types>> or other registered type.


To register the function its done by `ZetScript::registerFunction` passing a name as the symbol_name in _ZetScript_ and function reference.

 ZetScript zs;
 zs.registerFunction("zetscriptFunctionInterface",zetscriptFunctionInterface)


*Example*

The following example it registers a function called "sayHelloWorld" with no arguments and no return.

[source,c++]
----
include::../examples/the_api/register_function/register_function.cpp[]
----


Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_out.txt[]
----

==== Return types

This section will explain how to register functions that returns the following ZetScript types:

- Boolean
- Integer
- Float
- String
- Array
- Object
- A registered type

===== Return a Boolean

To call a C function that returns a ZetScript _Boolean_, it must create and register a C function that returns _bool_ as the return type.

*Example*

[source,c++]
----
include::../examples/the_api/register_function/register_function_return_bool.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_return_bool_out.txt[]
----


===== Return a Integer

To call a C function that returns a ZetScript _Integer_, it must create and register a C function that returns _<<zs_int>>_ as the return type.

*Example*

[source,c++]
----
include::../examples/the_api/register_function/register_function_return_zs_int.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_return_zs_int_out.txt[]
----

===== Return a Float

To call a C function that returns a ZetScript _Float_, it must create and register a C function that returns _<<zs_float>>_ as the return type.

*Example*

[source,c++]
----
include::../examples/the_api/register_function/register_function_return_zs_float.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_return_zs_float_out.txt[]
----

===== Return a String

To call a C function that returns a ZetScript _String_, it must create and register a C function that returns one the following as return types,

- _const char *_
- _zs_string_
- _StringScriptObject *_

====== Return a String as const char *

To call a C function that returns a ZetScript _String_, it can create and register a C function that returns _const char *_ as return type.

*Example*

[source,c++]
----
include::../examples/the_api/register_function/register_function_return_const_char.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_return_const_char_out.txt[]
----

====== Return a String as zs_string

To call a C function that returns a ZetScript _String_, it can create and register a C function that returns _<<zs_string>>_ as return type.

*Example*

[source,c++]
----
include::../examples/the_api/register_function/register_function_return_zs_string.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_return_zs_string_out.txt[]
----

====== Return a String as StringScriptObject *

To call a C function that returns a ZetScript _String_, it can create and register a C function that returns _<<StringScriptObject>>_ as return type. The instantiation of _<<StringScriptObject>>_ it's done throught _ZetScript::newStringScriptObject_ using _ZetScript *_ context.

*Example*

[source,c++]
----
include::../examples/the_api/register_function/register_function_return_string_script_object.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_return_string_script_object_out.txt[]
----

===== Return an Array

To call a C function that returns a ZetScript _Array_, it must create and register a C function that returns _<<ArrayScriptObject>>_ as return type. The instantiation of _<<ArrayScriptObject>>*_ it's done through _ZetScript::newArrayScriptObject_ using _ZetScript *_ context.

*Example*

[source,c++]
----
include::../examples/the_api/register_function/register_function_return_array_script_object.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_return_array_script_object_out.txt[]
----

===== Return a Object

To call a C function that returns a ZetScript _Object_, it must create and register a C function that returns _<<ObjectScriptObject>>*_ as return type. The instantiation of _<<ObjectScriptObject>>_ it's done through _ZetScript::newObjectScriptObject_ using _ZetScript *_ context.

*Example*

[source,c++]
----
include::../examples/the_api/register_function/register_function_return_object_script_object.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_return_object_script_object_out.txt[]
----


===== Return a registered type

To call a C function that returns a registered type, it must create and register a C function that returns _<<_ClassScriptObject>>*_ as return type. To instantiate _ClassScriptObject_ is done through _<<ZetScript::newClassScriptObject>>_ using _ZetScript *_ context passing instantiated registered type by parameter.


*Example*

[source,c++]
----
include::../examples/the_api/register_function/register_function_return_class_script_object.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_return_class_script_object_out.txt[]
----

==== Parameter types

This section will explain how to register functions that accepts the following ZetScript types as parameter,

- Boolean
- Integer
- Float
- String
- Array
- Object
- Function
- Registered type

===== Parameter as Boolean

To call a C function that accepts ZetScript _Boolean_, it must create and register a C function with _bool *_ as parameter type.

*Example*

[source,c++]
----
include::../examples/the_api/register_function/register_function_param_bool.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/register_function/register_function_param_bool_out.txt[]
----

===== Integer

A native function that accepts an input _integer_ value must define _zs_int_ or _zs_int *_ as parameter type.

*Example*

[source,c++]
----
include::../examples/the_api/bind_function/bind_function_param_zs_int.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_function/bind_function_param_zs_int_out.txt[]
----

===== Float

A native function that accepts an input _float_ value must define _zs_float *_ as parameter type.

*Example*

[source,c++]
----
include::../examples/the_api/bind_function/bind_function_param_zs_float.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_function/bind_function_param_zs_float_out.txt[]
----

===== String

A native function that accepts a _string_ value as argument can be defined by the following types:

- String as const char *
- String as zs_string *
- String as StringScriptObject *

===== String as const char *

A native function that accepts an input _string_ value can be defined   _const char *_ as parameter type.

*Example*

[source,c++]
----
include::../examples/the_api/bind_function/bind_function_param_const_char.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_function/bind_function_param_const_char_out.txt[]
----

===== String as zs_string *

A native function that accepts an input _string_ value can be defined   _zs_string *_ as parameter type.

*Example*

[source,c++]
----
include::../examples/the_api/bind_function/bind_function_param_zs_string.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_function/bind_function_param_zs_string_out.txt[]
----

===== String as StringScriptObject *

A native function that accepts an input _string_ value can define  _StringScriptObject *_ as parameter type.

*Example*

[source,c++]
----
include::../examples/the_api/bind_function/bind_function_param_string_script_object.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_function/bind_function_param_string_script_object_out.txt[]
----

===== Array

A native function that accepts _array_ value as input must define _ArrayScriptObject *_ as the parameter type.

*Example*

[source,c++]
----
include::../examples/the_api/bind_function/bind_function_param_array_script_object.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_function/bind_function_param_array_script_object_out.txt[]
----

===== Object

A native function that accepts _object_ value as input must define _ObjectScriptObject *_ as the parameter type.

*Example*

[source,c++]
----
include::../examples/the_api/bind_function/bind_function_param_object_script_object.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_function/bind_function_param_object_script_object_out.txt[]
----

===== Custom type

A native function that accepts a custom type value as argument is defined by the custom type pointer parameter type. The custom type must to be binded before through <<ZetScript::registerClass>>.

*Example*

[source,c++]
----
include::../examples/the_api/bind_function/bind_function_param_custom_type_object.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_function/bind_function_param_custom_type_object_out.txt[]
----

=== Bind script function

This section will explain the how to create a function interface to call a script function from C++ side.

When a script function is evaluated through `ZetScript::eval` or  `ZetScript::evalFile`, it can bind that script function through _ZetScript::bindFunction_ passing function signature template and the name of script function by parameter. The function signature must be configured with types defined in one of <<Built-in types>> or other types.

*Syntax*

[source,c++]
----
 ZetScript::registerFunction<ReturnType(Type1 _arg1, Type2 _arg2, ..., Type9 _arg9 )>("name_script_function")
----

Note that `ZetScript::bindScriptFunction` doesn't needs to have _ZetScript *_ defined as first parameter.

*Example*

The following example shows the binding of a script function without parameters and no return

[source,c++]
----
include::../examples/the_api/bind_script_function/bind_script_function.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_script_function/bind_script_function_out.txt[]
----

==== Return types

===== Boolean

To create binding of a script function that returns a _boolean_ value to C++ side it has to define function signature that returns _bool_

*Example*

[source,c++]
----
include::../examples/the_api/bind_script_function/bind_script_function_return_bool.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_script_function/bind_script_function_return_bool_out.txt[]
----

===== Integer

A script function that returns an _integer_ it must bind with a function signature that returns _zs_int_.

*Example*

[source,c++]
----
include::../examples/the_api/bind_script_function/bind_script_function_return_zs_int.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_script_function/bind_script_function_return_zs_int_out.txt[]
----

===== Float

A script function that returns an _float_ it must bind with a function signature that returns _zs_float_.

*Example*

[source,c++]
----
include::../examples/the_api/bind_script_function/bind_script_function_return_zs_float.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind_script_function/bind_script_function_return_zs_float_out.txt[]
----


==== bind member function from instanced global object

It can also call from instanced object

[source,c++]
----
include::../examples/the_api/bind/bin_object_script_function.cpp[]
----

Out:

[source,txt]
----
include::../examples/the_api/bind/bin_object_script_function_out.txt[]
----

==== Life time objects returned
//      zs_int,zs_float,bool
//      other times should bee freed. Show error if not freed

=== Bind function

To bind a function first it has to declare a function with a signature compatible to ZetScript. All signatures in a function binding interface have ZetScript pointer as first parameter, and the others are <<built-in types>> or types binded by the user. 

Example,

Parameters

ZetScript supports builtin *zs_int, zs_int *, zs_float *, bool *, char * and zs_string ** as arguments types or other types. 

Example,

Return

For return values it supports the same basic types as arguments plus *bool, zs_float and zs_string (no pointer)*. Is also possible to pass custom registered types (see section 4.3).

Example,

Is important to say that ZetScript has a constraint *maximum of 8 parameters* for any C function to be bind in the script engine. If a function more than 8 parameters is tried to be registered, ZetScript will throw an error. To bind C function is done through macro registerFunction. You have to provide the name that will be referenced in script side.

Syntax,

[source,cpp]
zs.registerFunction("function_name", c_function);

Example,

[source,cpp]
----
#include "ZetScript.h"

zetscript::zs_int add(zetscript::zs_int  op1, zetscript::zs_int op2)
{
	return op1+op2;
}

int main(int argc, char *argv[])
{
	zetscript::ZetScript zs;
	
	// binds native function "add"
	zs.registerFunction("add",add);
	
 	zs.eval(
 		"Console::outln(\"result:\"+add(5,4));" // prints "result: 9"
 	);
	 
 	return 0;
} 
---- 
 

=== Bind type

[source,cpp]
----
include::../examples/the_api/type/type_bind_type.cpp[]
----

==== Bind static type

Binding a native class or type as static it means it's not instantiable in the script side , so it cannot use *new* keyword.
To bind type as static is done through *registerClass* function by passing the type as template and the name that will be referenced in the script.

Example,

 zs.registerClass<type_class>("name_class");
 
The following code shows an example of a registering a C++ class,

[source,cpp]
----
class MyClass{
public:
	int data1;
	void init(int arg){
		printf("data1 is initialized as %i\n",arg);
		this->data1=arg;
	}

	void function1(int arg){
 		this->data1 = arg;
 		printf("c++ argument is %i\n",this->data1);
 	}
};
----
List 4.1

Using the list 4.1, to bind MyClass as static (i.e no instantiable) in script side is proceded as follows,

[source,cpp]
----
void main(argc, char *argv[])
{
	zetscript::ZetScript zs;
	
 	//register MyClass as static (i.e no instantiable) in script side.
 	zs.registerClass<MyClass>("MyClass");
 	
 	return 0;
 }
----

In the following example it evals a code to try instance MyClass type but it will throw an error that MyClass is not instanciable because is static,

[source,cpp]
----
void main(argc, char *argv[])
{
	zetscript::ZetScript zs;
	
 	//register MyClass as static (i.e no instantiable) in script side.
 	zs.registerClass<MyClass>("MyClass");

	 	
	// It throws an error that MyClass is not instanciable because is static
 	zs.eval(
 		"var myclass= new MyClass();"
 	);
 	
 	return 0;
 }
----

In order to use a MyClass instantiation it has to be done in the C++ aplication. 

For example,

[source,cpp]
----

MyClass *my_class=NULL;

// interface function to get MyClass instantiation
MyClass *getMyClass(){
	return 	my_class;
}


void main(argc, char *argv[])
{
	zetscript::ZetScript zs;
	
	// create MyClass instantiation from C++
	my_class=new MyClass();
	
	
 	//register MyClass as static (i.e no instantiable) in script side.
 	zs.registerClass<MyClass>("MyClass");
 	
 	 //register function interface to get MyClass instantiation
 	zs.registerFunction("getMyClass",getMyClass);
 	
 	
	// It get MyClass reference
 	zs.eval(
 		"var my_class= getMyClass();" 
 	);
 	
 	// delete MyClass instantiation from C++
 	delete my_class;
 	
 	return 0;
 }
----
 
Note: Is valuable to see that static types are safety because never are created in the script side, they are created by the C++ side 
 
==== Bind instantiable type

Binding class or type as instantiable means that can it be instanced in the script side by using *new* keyword. To bind a instantiable type is done through *registerClass* passing the type as template,the name and the interface new/delete functions,

Example,

[source,cpp]
----
 zs.registerClass<MyClass>("MyClass",new_function, delete_function);
----

Using the list 4.1, to bind MyClass as instanciable in script side is proceded as follows,

[source,cpp]
----

MyClass *MyClass_new(){
	return new MyClass(); 
}

void MyClass_delete(MyClass *_this){
	delete _this;
}


void main(argc, char *argv[])
{
	zetscript::ZetScript zs;

	//register MyClass as instantiable type in script side.
	zs.registerClass<MyClass>("MyClass",MyClass_new,MyClass_delete); 
	
	// It instances MyClass
 	zs.eval(
 		"var my_class= new MyClass();" 
 	);
	
	return 0;
}
----
 
==== Delete C Class

ZetScript it has a garbage collector to delete unreferenced script variables when the end of scope is reached but it keeps alive its internal native pointer to avoid unintended segmentation faults. So to avoid memory leaks due this issue, the user has to delete manually any instanced C Class variable with delete keyword. The following code shows an example of using delete keyword,

[source,javascript]
----
 delete myclass; // script and c variable is destroyed.
---- 
  
=== Bind members

==== Bind Function Member

The binding of variable member is done like binding c function but in this case is done through the macro function registerMemberFunction. You have to provide the type class, the string name that will be referenced in script side and the function object reference.

 registerMemberFunction<ObjectType>("function_name",&ObjectType::function_name);

As an example, the following code registers function member MyClass::function1 seen on List 4.1

[source,cpp]
----
zs.bindFunctionMember<MyClass>("function1",&native_function1);
----

And then it can access to function1 member through field access ('.')

[source,cpp]
----
var myclass= new MyClass();
---- 

myclass.function1(10); // prints "c++ argument is10"

==== Bind function constructor

ZetScript always calls default C++ constructor when a variable is instanced with C++ type. ZetScript has no support of parameterized constructors but, instead, it can be done by registering a function with same name as the class name registered. As an example, the following code registers function member MyClass::init seen on List 4.1 as constructor3,

[source,cpp]
----
zs.bindFunctionMember<MyClass>("MyClass",&MyClass::init);
----

And then, when variable is intancedwe can instance the class passing a integer as parameter to the c contructor

[source,javascript]
----
var myclass= new MyClass(10); // prints "data1 is initialized as 10"
----

4.3.6 Inheritance

Inherited classes needs to know its base classes in order to register its parent variables
and symbols already registered with the functions already seen in the section 4.3.3 and
4.3.4 respectively. To tell the which base class has an inherited class is done through
class_C_baseof with two parameters: The first parameter as the inherited class type
and second parameter as its base class type.
Syntax,


[source,cpp]
----
zs.extends<class, base_class>();
----


If for example we want to register MyClassExtend and tell that is base of MyClass Is
done with the following snipped,

[source,cpp]
----
class MyClassExtend:public MyClass{
public:
	float data2;
	void function2(float * arg){
 		this->data2 = *arg;
 		printf("Float argument is %.02f\n",this->data2);
 	}
};

zs.registerClass<MyClassExtend>("MyClassExtend"); // register MyClassExtend
zs.extends<MyClassExtend,MyClass>();
----
List 4.2

3
 Note that the name of the function is the same as the name of the class



=== Bind static constant variable

The binding of variable member is done through the macro function *bindMemberVariable*. You have to provide the type class, the string name that
will be referenced in script side and variable object reference.

Sintax,

[source,cpp]
----
zs.bindStaticConstantVariableMember<ObjectType>("variable_name",&ObjectType::variable_name);
----


As an example, the following code register variable member MyClass::data1 seen on
List 4.1,


register_C_VariableMember<MyClass>("data1",&MyClass::data1);
And then it can access to data1 member through field access ('.')


var myclass= new MyClass();
print("data1"+myclass.data1);


 
 4.4 Inheritance script class from c++ class
An important feature of ZetScript is that it supports c++ class inheritance for any in
script class and the this (section 3.9) and super (seccion 3.9.5.1) keywords works as a
normal behavior
For example, we could inherit MyClassExtend from 4.2 that is shown in the following
code,


[source,javascript]
----
class ScriptMyClassExtended extends MyClassExtend{
 function1(arg1){
 	Console::outln("script argument is "+arg1)
 	super(this.data1+arg1); // calls function1 c++
 }
}


var myclass=new ScriptMyClassExtend(10);
Myclass.function1(5);

----

data1 is initialized as 10
script argument is 5
c++ argument is 15 

Complete example



4.5 Call script function in C++
To bind script call in c++ it can be done through bind_function passing the function type
as template parameter and the function name as parameter4
. It can bind a script
function member from an already instanced object.
Example,
#include "CZetScript.h"
using namespace zetscript;
int main(){
 CZetScript *zs = CZetScript::getInstance(); // instance zetscript
 zs->eval(
 "class Test{"
 " var data1;"
 " function function1(arg){"
 " print(\"calling Test.Function:\"+arg);"
 " }"
 "};"
 ""
 "function delete_test(){"
 " delete test;"
 " print(\"test variable was deleted\");"
 "}"
 ""
 "var test=new Test();"
 );
 // delete_test function is evaluated now test variable is instanced as Test type, so it can
 // bind test.function1

// instance function delete_test function.
std::function<void()> * delete_test=bind_function<void()>("delete_test");
// instance member function test.function1.
std::function<void(int)> * test_function1=bind_function<void (int)>("test.function1");
 (*test_function1)(10); // it calls "test.function" member function with 10 as parameter.
 (*delete_test)(); // it calls "delete_test" function with no parameters
 // delete functions when they are used anymore
 delete test_function1;
 delete delete_test;
}

4 C++ function binding is limited by a maximum of 6 parameters

== 3.10 Metamethods
Metamethods are special functions members that links with operators seen on section section 3.6. ZetScript metamethods can be static or member function footnote:[ On script side, static function is defined as member function, but user should not access on
variable/function members as well it happens on c++ static function.]  depending whether the operation affects or not the object itself.

ZetScript supports the following metamethods:

* _equ
* _not_equ
* _lt
* _lte
* _gt
* _gte
* _not
* _neg
* _add
* _div
* _mul
* _mod
* _and
* _or
* _xor
* _shl
* _shr
* _set


=== 5.5.1 _equ (aka ==)

@Description: Performs relational equal operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if equal, false otherwise.
Script Example
Example how to use _equ metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _equ(op1, op2){
 return op1.num==op2.num;
 }
};

var n1 = new MyNumber (1), n2=new MyNumber (1);

if(n1==n2){ // we use here the metamethod ==
 print("n1 ("+n1.num+") is equal to n2 ("+n2.num+")");
} 

C++ Example
The same it can be done with C++. The C++ metamethod function associated with
must be static.
#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 void set(int _n){
 this->num=_n;
 }
 static bool _equ(MyNumber *op1, MyNumber *op2){
 return op1->num == op2->num;
 }
};

int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _equ as metamethod
 registerStaticMemberFunction<MyNumber>("_equ",&MyNumber::_equ);
 if(!zs->eval(
"var n1 = new MyNumber (1), n2=new MyNumber (1); \n "
"if(n1==n2){ // we use here the metamethod ==\n "
" print(\"n1 (\"+n1.num+\") is equal to n2 (\"+n2.num+\")\");\n "
"}\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.2 _nequ (aka !=)

@Description: Performs relational not equal operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if not equal, false otherwise.

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 void set(int _n){
 this->num=_n;
 }
 static bool _nequ(MyNumber *op1, MyNumber *op2){
 return op1->num != op2->num;
 }
};

int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _not_equ as metamethod
 registerStaticMemberFunction<MyNumber>("_nequ",&MyNumber::_nequ);
 if(!zs->eval(
"var n1 = new MyNumber (1), n2=new MyNumber (0); \n "
"if(n1!=n2){ // we use here the metamethod != \n "
" print(\"n1 (\"+n1.num+\") is not equal to n2 (\"+n2.num+\")\");\n "
"}\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
} 

=== 5.5.3 _lt (aka <)

@Description: Performs relational less equal operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if less equal, false otherwise.


The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 void set(int _n){
 this->num=_n;
 }
 static bool _lt(MyNumber *op1, MyNumber *op2){
 return op1->num < op2->num;
 }
};

int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _lt as metamethod
 registerStaticMemberFunction<MyNumber>("_lt",&MyNumber::_lt);
 if(!zs->eval(
 "var n1 = new MyNumber (0), n2=new MyNumber (1);\n"
"if(n1<n2){ \n "
" print(\"n1 (\"+n1.num+\") is less than n2 (\"+n2.num+\")\");\n "
"}\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.4 _lte (aka <=)

@Description: Performs relational less equal operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if less equal, false otherwise.

C++ Example
The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 void set(int _n){
 this->num=_n;
 }
 static bool _lte (MyNumber *op1, MyNumber *op2){
 return op1->num <= op2->num;
 }
};

int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _lte as metamethod
 registerStaticMemberFunction<MyNumber>("_lte",&MyNumber::_lte);
 if(!zs->eval(
"var n1 = new MyNumber (1), n2=new MyNumber (1);\n"
"if(n1<=n2){\n"
" print(\"n1 (\"+n1.num+\") is less equal than n2 (\"+n2.num+\")\");\n"
"}\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.5 _gt (aka >)

@Description: Performs relational greater operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if greater, false otherwise.

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 void set(int _n){
 this->num=_n;
 }
 static bool _gt(MyNumber *op1, MyNumber *op2){
 return op1->num > op2->num;
 }
};
int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _gt as metamethod
 registerStaticMemberFunction<MyNumber>("_gt",&MyNumber::_gt);
 if(!zs->eval(
"var n1 = new MyNumber (1), n2=new MyNumber (0);\n"
"if(n1>n2){ \n"
" print(\"n1 (\"+n1.num+\") is greater than n2 (\"+n2.num+\")\");\n"
"}\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.6 _gte (aka >=)

@Description: Performs relational greater equal operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if greater equal, false otherwise.

C++ Example

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 void set(int _n){
 this->num=_n;
 }
 static bool _gte(MyNumber *op1, MyNumber *op2){
 return op1->num >= op2->num;
 }
};
int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _gte as metamethod
 registerStaticMemberFunction<MyNumber>("_gte",&MyNumber::_gte);
 if(!zs->eval(
"var n1 = new MyNumber (1), n2=new MyNumber (1); \n "
"if(n1>=n2){ \n "
" print(\"n1 (\"+n1.num+\") is greater equal than n2 (\"+n2.num+\")\");\n "
"}\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.7 static _not (aka !)

@Description: Performs a not operation.
@Param1 : Object custom class type.
@Returns : A Boolean type as a result of not operation.


The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyBoolean{
public:
 bool b;
 MyBoolean (){
 this->b=false;
 }
 void set(bool _b){
 this->b=_b;
 }
 static bool _not(MyBoolean *op1){
 return !op1->b;
 }
};

int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class< MyBoolean >("MyBoolean");
 // register variable member num
 register_C_VariableMember<MyBoolean>("b", &MyBoolean::b);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyBoolean>("MyBoolean", &MyBoolean:: set);
 // register static function _not as metamethod
 registerStaticMemberFunction<MyBoolean>("_not", &MyBoolean::_not);
 if(!zs->eval(
"var b = new MyBoolean (false);\n"
"if(!b){ \n"
" print(\"b was false\");\n"
"}\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
} 

=== 5.5.8 _neg (aka -)

@Description: Performs negate operation.
@Param1 : operand to negate.
@Returns : A new object custom class type with result of negate operation.


The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _num){
 this->num=_num;
 }
 void set(int _n){
 this->num=_n;
 }
 static MyNumber * _neg(MyNumber *op1){
 return new MyNumber(-op1->num);
 }
};
int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _neg as metamethod
 registerStaticMemberFunction<MyNumber>("_neg",&MyNumber::_neg);
 if(!zs->eval (
"var n1 = new MyNumber (1);\n"
"var n2 = -n1;\n"
"print(\"neg of n1 (\"+n1.num+\") is (\"+n2.num+\")\");\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.9 _add (aka +)

@Description: Performs add operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result add operation.

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _n){
 this->num=_n;
 }
 void set(int _n){
 this->num=_n;
 }
 static MyNumber * _add(MyNumber *op1, MyNumber *op2){
 return new MyNumber(op1->num + op2->num);
 }
};
int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _add as metamethod
 registerStaticMemberFunction<MyNumber>("_add",&MyNumber::_add);
 if(!zs->eval(
"var n1 = new MyNumber (20);\n"
"var n2 = new MyNumber (10); \n"
"var n3 =n1+n2; \n "
"print(\"n1 (\"+n1.num+\") + n2 (\"+n2.num+\") = \"+n3.num);\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
} 

=== 5.5.10 _div (aka /)

@Type: Static
@Description: Performs divide operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result divide operation.

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _n){
 this->num=_n;
 }
 void set(int _n){
 this->num=_n;
 }
 static MyNumber *_div(MyNumber *op1, MyNumber *op2){
 return new MyNumber(op1->num / op2->num);
 }
};
int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _div as metamethod
 registerStaticMemberFunction<MyNumber>("_div",&MyNumber::_div);
 if(!zs->eval(
"var n1 = new MyNumber (20);\n"
"var n2 = new MyNumber (10);\n"
"var n3 =n1/n2;\n"
"\n"
"print(\"n1 (\"+n1.num+\") / n2 (\"+n2.num+\") = \"+n3.num);\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.11 _mul (aka *)

@Type: Static
@Description: Performs multiply operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result multiply operation.

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _n){
 this->num=_n;
 }
 void set(int _n){
 this->num=_n;
 }
 static MyNumber *_mul(MyNumber *op1, MyNumber *op2){
 return new MyNumber(op1->num * op2->num);
 }
};
int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _mul as metamethod
 registerStaticMemberFunction<MyNumber>("_mul",&MyNumber::_mul);
 if(!zs->eval(
"var n1 = new MyNumber (20);\n"
"var n2 = new MyNumber (10);\n"
"var n3 =n1*n2;\n"
"\n"
"print(\"n1 (\"+n1.num+\") * n2 (\"+n2.num+\") = \"+n3.num);\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.12 _mod (aka %)

@Description: Performs modulus operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result modulus operation.

C++ Example

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _n){
 this->num=_n;
 }
 void set(int _n){
 this->num=_n;
 }
 static MyNumber *_mod(MyNumber *op1, MyNumber *op2){
 return new MyNumber(op1->num % op2->num);
 }
};
int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _mod as metamethod
 registerStaticMemberFunction<MyNumber>("_mod",&MyNumber::_mod);
 if(!zs->eval(
"var n1 = new MyNumber (20);\n"
"var n2 = new MyNumber (15);\n"
"var n3 =n1%n2;\n"
"\n"
"print(\"n1 (\"+n1.num+\") % n2 (\"+n2.num+\") = \"+n3.num);\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.13 _and (aka &)

@Description: Performs binary and operation between two integer
operands.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result of binary and operation.

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _n){
 this->num=_n;
 }
 void set(int _n){
 this->num=_n;
 }
 static MyNumber * _and(MyNumber *op1, MyNumber *op2){
 return new MyNumber (op1->num & op2->num);
 }
};
int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _and as metamethod
 registerStaticMemberFunction<MyNumber>("_and",&MyNumber::_and);
 if(!zs->eval(
"var n1 = new MyNumber (0xff);\n"
"var n2 = new MyNumber (0x0f);\n"
"var n3 =n1&n2;\n"
"\n"
"print(\"n1 (\"+n1.num+\") & n2 (\"+n2.num+\") = \"+n3.num);\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
} 

=== 5.5.14 _or (aka |)

@Description: Performs binary or operation between two integer
operands.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result of binary or operation.

C++ Example
The same it can be done with C++. The C++ metamethod function associated with
must be static.
#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _n){
 this->num=_n;
 }
 void set(int _n){
 this->num=_n;
 }
 static MyNumber * _or(MyNumber *op1, MyNumber *op2){
 return new MyNumber(op1->num | op2->num);
 }
};

int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _or as metamethod
 registerStaticMemberFunction<MyNumber>("_or",&MyNumber::_or);
 if(!zs->eval(
"var n1 = new MyNumber (0xf0);\n"
"var n2 = new MyNumber (0x0f);\n"
"var n3 =n1|n2;\n"
"\n"
"print(\"n1 (\"+n1.num+\") | n2 (\"+n2.num+\") = \"+n3.num);\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
} 

=== 5.5.15 _xor (aka ^)
@Description: Performs a binary xor operation between two integer
operands.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result of binary xor operation.

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _n){
 this->num=_n;
 }
 void set(int _n){
 this->num=_n;
 }
 static MyNumber *_xor(MyNumber *op1, MyNumber *op2){
 return new MyNumber(op1->num ^ op2->num);
 }
};

int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _xor as metamethod
 registerStaticMemberFunction<MyNumber>("_xor",&MyNumber::_xor);
 if(!zs->eval(
"var n1 = new MyNumber (0xf1);\n"
"var n2 = new MyNumber (0x0f);\n"
"var n3 =n1^n2;"
"\n"
"print(\"n1 (\"+n1.num+\") ^ n2 (\"+n2.num+\") = \"+n3.num);\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.16 _shl (aka <<)

@Description: Performs shift left operation.
@Param1 : Variable to apply shift left.
@Param2 : Tells number shifts to the left.
@Returns : A new object custom class type with n shifts left operation.

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _n){
 this->num=_n;
 }
 void set(int _n){
 this->num=_n;
 }
 static MyNumber *_shl(MyNumber *op1, int n_shifts){
 return new MyNumber(op1->num << n_shifts);
 }
};

int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _shl as metamethod
 registerStaticMemberFunction<MyNumber>("_shl",&MyNumber::_shl);
 if(!zs->eval(
"var n1 = new MyNumber (0x1);\n"
"var n2 = n1 << 3;\n"
"\n"
"print(\"n1 (\"+n1.num+\") << 3 = \"+n2.num);\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.17 _shr (aka >>)

@Description: Performs shift right operation.
@Param1 : Variable to apply shift right.
@Param2 : Tells number shifts to the right.
@Returns : A new object custom class type with n shifts right operation.

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _n){
 this->num=_n;
 }
 void set(int _n){
 this->num=_n;
 }
 static MyNumber * _shr(MyNumber *op1,int n_shifts){
 return new MyNumber(op1->num >> n_shifts);
 }
};

int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register static function _shr as metamethod
 registerStaticMemberFunction<MyNumber>("_shr",&MyNumber::_shr);
 if(!zs->eval(
"var n1 = new MyNumber (0xf);\n"
"var n2 = n1 >> 2;\n"
"\n"
"print(\"n1 (\"+n1.num+\") >> 2 = \"+n2.num);\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.19 _set (aka =)

@Description: Performs a set operation6.
@Param1 : Source variable to set.
@Returns : None.

The same it can be done with C++. The C++ metamethod function associated with must be static.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 int num;
 MyNumber(){
 this->num=0;
 }
 void _set(int _n){
 this->num=_n;
 }
 void _set(MyNumber *_n){
 this->num=_n->num;
 }
};
int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 // register variable member num
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::_set
 registerMemberFunction<MyNumber>(
"MyNumber"
, static_cast<void (MyNumber::*)(int)>(&MyNumber::_set)
 );
 // register two types function _set as metamethod (same as constructor)
 registerMemberFunction<MyNumber>(
"_set"
,static_cast<void (MyNumber::*)(int)>(&MyNumber::_set)
 );
 registerMemberFunction<MyNumber>(
"_set"
, static_cast<void (MyNumber::*)(MyNumber *)>(&MyNumber::_set)
 );
 if(!zs->eval(
"var n1 = new MyNumber (10);\n"
"var n2 = new MyNumber (20); \n"
"var n3; //  n3 is undefined! \n"
"n3 = n2; //  it assigns n2 pointer. \n"
"print(\"n3:\"+n3.num); \n"
"n3=n1; //  n3.num = n2.num = n1.num. \n"
"print(\"n3:\"+n3.num); \n"
"n3=50; //  n3.num = n2.num = 10. \n"
"print(\"n3:\"+n3.num); \n"
"n3=false; //  stops execution with error because is not supported.\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}

=== 5.5.20 Mixing operand types

Working with metamethods might have situations where you are passing different type parameters. You can pass the object type, where metamethod function is implemented, or other type of parameters like integer, string, etc.
The following example performs a sums of a combination of object, integers or floats.

var num1= new MyNumber(1), num2=new MyNumber(2);
var num3= 1.0 + num1 + 6 + 1 + 10.0 + num2 + 10 + num1 + num2;

The expression cannot be performed with only objects as we have been shown in the
last sections. You can use instanceof operator to check each type of argument and
perform the needed operation.

We present an example for _add metamethod function that implements a support to
operate with MyNumber object, integer or float. Other types will cause a execution
error.

The same example for C++ we can to do an extra effort. We have to implement all possibilities that operator contemplates with operation within MyNumber, int or float.

#include "CZetScript.h"
using namespace zetscript;
class MyNumber{
public:
 float num;
 MyNumber(){
 this->num=0;
 }
 MyNumber(int _n){
 this->num=_n;
 }
 void set(int _n){
 this->num=_n;
 }
 // MyNumber,MyNumber combination
 static MyNumber * _add(MyNumber *op1, MyNumber *op2){
 return new MyNumber(op1->num + op2->num);
 }
 // int,MyNumber combination
 static MyNumber * _add(int op1, MyNumber *op2){
 return new MyNumber(op1 + op2->num);
 }
 // MyNumber,int combination
 static MyNumber * _add( MyNumber *op1, int op2){
 return new MyNumber(op1->num + op2);
 }
 // float,MyNumber combination
 static MyNumber * _add(float *op1, MyNumber *op2){
 return new MyNumber(*op1 + op2->num);
 }
 // MyNumber,float combination
 static MyNumber * _add( MyNumber *op1, float *op2){
 return new MyNumber(op1->num + *op2);
 }
};
int main(){
 CZetScript *zs = CZetScript::getInstance();
 // register class MyNumber
 register_C_Class<MyNumber>("MyNumber");
 register_C_VariableMember<MyNumber>("num",&MyNumber::num);
 // register constructor through function MyNumber::set
 registerMemberFunction<MyNumber>("MyNumber",&MyNumber:: set);
 // register 1st _add metamethod function to satisfy operand (MyNumber,MyNumber) combination
 registerStaticMemberFunction<MyNumber>("_add",static_cast< MyNumber * (*)(MyNumber *, MyNumber *)>(&MyNumber::_add));
 // register 2nd _add metamethod function to satisfy operand (int,MyNumber) combination
 registerStaticMemberFunction<MyNumber>("_add",static_cast< MyNumber * (*)(int, MyNumber *)>(&MyNumber::_add));
 // register 3rd _add metamethod function to satisfy operand (MyNumber,int) combination
 registerStaticMemberFunction<MyNumber>("_add",static_cast< MyNumber * (*)(MyNumber *, int)> (&MyNumber::_add));
 // register 4th _add metamethod function to satisfy operand (float,MyNumber) combination
 registerStaticMemberFunction<MyNumber>("_add",static_cast< MyNumber * (*)(float *, MyNumber *)>(&MyNumber::_add));
 // register 5th _add metamethod function to satisfy operand (MyNumber,float) combination
 registerStaticMemberFunction<MyNumber>("_add",static_cast< MyNumber * (*)(MyNumber *, float *)>(&MyNumber::_add));
 if(!zs->eval(
"var n1 = new MyNumber (20);\n"
"var n2 = new MyNumber (10);\n"
"var n3 =1+n1+5+7+n2+10.0+7.0+10; // mix operation with MyNumber, integer and number\n"
"print(\"n3:\"+n3.num);\n"
 )){
 fprintf(stderr,ZS_GET_ERROR_MSG());
 }
 return 0;
}


=== Types

ZetScript includes the following set of types,

- zs_int
- zs_float
- zs_string
- StringStringObject
- ArrayStringObject
- ObjectStringObject
- zs_datetime
- zs_timespan
- zs_buffer
- zs_vector

==== zetscript::ZetScript

ZetScript instance usually used to give reference and perform operations in the current context.



==== zs_int

Integer data type it defines a integer variable with range from `-(2^b-1^)` to `2^b-1^-1` where `b=32` or `b=64` it depending whether ZetScript is compiled for 32bits or 64bits. 

*Example*

[source,c++]
----
zetscript::zs_int i=10;
----

==== zs_float

_zs_float_ type it defines a float variable represented as IEEE-754 floating point numbers in 32-bit or 64 bit it depending whether ZetScript is compiled for 32bits or 64bits.

*Example*

[source,c++]
----
zetscript::zs_float f=20.5;
----

==== zs_string

_zs_string_ it defines a string represented a sequence of chars

*Example*

[source,c++]
----
zetscript::zs_string s="Hello World";
----

==== StringScriptObject

_StringScriptObject_ it defines a string script object and encapsules _zs_string_ reference. It uses zetscript context in order to be instanced

*Example*

[source,c++]
----
zetscript::StringScriptObject str=zs.newStringScriptObject();
str.set("Hello World");
----

See <<zetscript::StringScriptObject>> for more information

==== ArrayScriptObject

_ArrayScriptObject_ it defines a array script object that acts as a array container of elements. It uses zetscript context in order to be instanced

*Example*

[source,c++]
----
zetscript::ArrayScriptObject array=zs.newArrayScriptObject();

// push as integer 10 value
object->push<zetscript::zs_int>(10)
----

See <<zetscript::ArrayScriptObject>> for more information


==== ObjectScriptObject

_ObjectScriptObject_ it defines a object script object that acts as a container of fields. It uses zetscript context in order to be instanced

*Example*

[source,c++]
----
zetscript::ObjectScriptObject *object=zs.newObjectScriptObject();

// add field "a" and 10 int as value
object->set<zetscript::zs_int>("a",10)

----

See <<zetscript::ObjectScriptObject>> for more information

==== zetscript::FunctionObject

_FunctionObject_ it defines a function object that contains function information.



==== zetscript::zs_string

===== Member functions

====== zs_string::zs_string()
====== zs_string::operator=()
====== zs_string::operator+=()
====== zs_string::operator[]
====== zs_string::at()
====== zs_string::clear()
====== zs_string::substr()
====== zs_string::operator+()
====== zs_string::operator==()
====== zs_string::operator!=()
====== zs_string::find()
====== zs_string::find_last_of()
====== zs_string::replace()
====== zs_string::append()
====== zs_string::erase()
====== zs_string::insert()
====== zs_string::empty()
====== zs_string::length()
====== zs_string::c_str()
====== zs_string::~zs_string()





==== zetscript::zs_vector

_zs_vector_ it defines a vector represented a sequence of elements for type template set

*Example*

[source,c++]
----
zetscript::zs_vector<zetscript::zs_int> v;

for(int i=0;i<10;i++){
	v.push_back(i);
}
----

===== zs_vector::zs_vector()
===== zs_vector::operator=()
===== zs_vector::set();
===== zs_vector::get();
===== zs_vector::erase();
===== zs_vector::push_back();
===== zs_vector::concat();
===== zs_vector::insert();
===== zs_vector::clear();
===== zs_vector::pop_back();
===== zs_vector::resize();
===== zs_vector::data()
===== zs_vector::size()
===== zs_vector::~zs_vector()

 
=== Helper functions

ZetScript includes the following set of helper functions,

- zs_file
- zs_dir
- zs_io
- zs_path
- zs_strutils
- zs_rtti
- zs_system

==== zs_file
==== zs_dir
==== zs_io
==== zs_path
==== zs_strutils
==== zs_rtti
==== zs_system

=== Byte codes

The following table shows the byte codes and its meaning

[cols="1m,2d,3d,6a"]
|====
|Instruction |Name |Description |Example

		EQU";  // ==
			INSTANCEOF";  // ==
			NOT_EQU" ;  // !=
			LT";  // <
			LTE";  // <=
			NOT"; // !
			GT";  // >
			GTE"; // >=
			NEG"; // !
			BWC"; // ~
			ADD"; // +
			SUB"; // -
			LOGIC_AND"; // &&
			LOGIC_OR";  // ||
			DIV"; // /
			MUL"; // *
			MOD";  // %
			AND"; // bitwise logic and
			OR"; // bitwise logic or
			XOR"; // logic xor
			SHL"; // shift left
			SHR"; // shift right
			STORE"; // =
			STORE_ADD"; // +=
			STORE_SUB"; // -=
			STORE_MUL"; // *=
			STORE_DIV"; // /=
			STORE_MOD"; // %=
			STORE_AND"; // &=
			STORE_OR"; // |=
			STORE_XOR"; // ^=
			STORE_SHL"; // <<=
			STORE_SHR"; // >>=
			PUSH_STK_GLOBAL_IRGO"; // load type var
			PUSH_STK_GLOBAL"; // push stk global
			PUSH_STK_LOCAL"; // push stk global
			PUSH_STK_REF"; // push stk global
			PUSH_STK_THIS"; // push stk global
			PUSH_STK_VEC@ITEM"; // load element vector
			PUSH_STK_OBJ@ITEM"; // load element object
			PUSH_STK_THIS@VAR"; // load element object

			LOAD_GLOBAL"; // load type var
			LOAD_LOCAL"; // load type var
			LOAD_REF"; // load type var
			LOAD_THIS"; // load type var
			LOAD_CONSTRUCTOR_FUNCT"; // load type var
			LOAD_???"; // load to find global
			// CALL
			CALL; // direct call
			CALL???"; // direct call
			STK_CALL"; // stack call


			MEMBER_CALL"; // this indirect call through dynamic symbol
			LOAD_THIS@VAR"; // load element object
			LOAD_THIS@FUN"; // load element object
			LOAD_VEC@ITEM"; // load element vector
			LOAD_OBJ@ITEM"; // load element object
			LOAD_FUN"; // load function
			LOAD_UNDEFINED"; // load undfined
			LOAD_NULL"; // load null
			LOAD_STK"; // load stack element

			LOAD_STR"; // load string
			LOAD_FLT"; // load float
			LOAD_BOOL"; // load bool
			LOAD_INT"; // load zs_int
			LOAD_TYPE"; // load to find
			JMP"; // Unconditional jump.
			JMP_CASE"; // Last jmp case
			JNT"; // goto if not true ... goes end to conditional.
			JT"; // goto if true ... goes end to conditional.
			JE_CASE"; // je case equal ... goes end to conditional.
			CALL_CONSTRUCTOR"; // calling function after all of arguments are processed...
			NEW_VEC"; // Array object (CREATE)
			PUSH_VITEM"; // Value push for stdvector
			RET"; // Value pop for stdvector
			NEW_OBJECT_BY_TYPE"; // New object (CREATE)
			NEW_OBJECT_BY_VALUE"; // New object (CREATE)
			DELETE";
			POP_SCOPE"; // New object (CREATE)
			PUSH_SCOPE"; // New object (CREATE)
			PUSH_OITEM"; // New object (CREATE)
			NEW_OBJECT"; // New object (CREATE)
			NEW_STR";
			IT_INIT"; // BYTE_CODE_IT_CHK_END
			STORE_CONST"; // BYTE_CODE_STORE_CONST
			PRE_INC"; // ++i
			PRE_DEC"; // --i
			POST_INC"; // i++
			NEG_POST_INC"; // -i++
			BWC_POST_INC"; // ~i++
			POST_DEC"; // i--
			BWC_POST_DEC"; // ~i--
			RESET_STACK"; // POP ONE AND IT MARKS END EXPRESSION
			CLEAR_ZERO_POINTERS";
			TYPEOF"; // POP ONE AND IT MARKS END EXPRESSION
			IN"; // POP ONE AND IT MARKS END EXPRESSION
|====