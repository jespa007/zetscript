=== Eval 

The ZetScript pipeline has three main processes,
1. Parsing: It decomposes expressions from input file or input strings into AST Nodes.
Also it registers classes and function as it needs.
2. Compile: AST Nodes are compiled and it turns in byte code operands.
3. Execute: Execute current compiled code.
To evaluate scripts it can be done through a set of string expressions (eval function) or file/s
(eval_file function)
==== 2.1. Evaluate string
Example evaluating a script through string in c++ , 
[source]
#include "CZetScript.h"
using namespace zetscript;
int main(){
 CZetScript *zs = CZetScript::getInstance();
 zs->eval(
 "print( \"Hello world\")"
 );
} 

==== 2.2. Evaluate file

Example evaluating a script through a file, 
file.zs
Console::outln("Hello World");



[source]
#include "CZetScript.h"
using namespace zetscript;
int main(){
 CZetScript *zs = CZetScript::getInstance();
 zs->eval_file(
 "file.zs"
 );
} 

==== 2.3 Evaluate but no execute
By default, evaluation process compiles and execute but it can tell to not execute passing
second parameter as false,

[source]
CZetScript *zs = CZetScript::getInstance();
 zs->eval_file(
 "file.zs",
false //<-- Tell to ZetScript no execute the compiled state
 ); 
 
 

==== 2.5 Exceptions
===== 2.5.1 Script exception
To catch eval or runtime errors it can be done through function
CZetScript::getErrorMsg or with ZS_GET_ERROR_MSG macro,
Example, 

[source]
#include "CZetScript.h"
using namespace zetscript;
int main(){
 CZetScript *zs = CZetScript::getInstance();
if(!zs->eval_file(
 "file.zs"
 )){
 printf("Error:%s\n", CZetScript::getErrorMsg()); // show error
}
} 

===== 2.5.2 User error

If the user wants to stop virtual machine execution due an unexpected value during part of the
code, it can call error function passing the error message.
Example,

[source]
if(n == undefined){
error("Unexpected error");
} 


==== 2.6 Save/Restore state
ZetScript supports a way to save current compiled state. This operation saves AST nodes,
global variables, registered C variables, C functions and C classes.
Save/restore operation is useful when, for instance, user wants to reload a set of script files.
Because global variables must be visible for all script files evaluated, global variables are
persistent, so they are not removed on each evaluation, it can only removed by restoring a
state.

===== 2.6.1 Save state
To save current state we have to invoke CState::saveState. This function returns an index that
tells compiled state index saved.

[source]
CState::saveState()

===== 2.6.2 Restore state
To restore a previous state we have to invoke CState::restoreState passing compiled state
index.

[source]
CState::setState(idx) 


And then it can get the message through getErrorMsg() inside C++ application. 


[NOTE]
.Some note about what you are reading
=====================================================================
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint
occaecat cupidatat non proident, sunt in culpa qui officia deserunt
mollit anim id est laborum.
=====================================================================

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint
occaecat cupidatat non proident, sunt in culpa qui officia deserunt
mollit anim id est laborum.


