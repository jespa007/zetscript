:source-highlighter: highlight.js
:highlightjs-languages: rust, swift

== 3. The language

=== 3.1 Statments

ZetScript Language is based on a set of statements formed by values, operators, expressions, keywords, declarations, expressions, conditionals, integrators and functions. All statements are separated by semicolons at the end.

Example of four statements,

[source,javascript]
----
var op1,op2,res;
op1 = 5;
op2 = 6;
res = 5+6;
----

The last example can be executed within one line,

[source,javascript]
----
var op1,op2,res; op1=5; op2=6; res = 5+6;
----

=== 3.2 Comments

ZetScript support block and line comments.

==== 3.2.1 Block comment

[source,javascript]
----
/*
this is a block comment
*/
----

==== 3.2.2 Line comment

[source,javascript]
----
// This is a line comment
----

=== 3.3 Literals

ZetScript supports the following literals,

* boolean
* integer
* float
* string

==== 3.3.1 Boolean literal

Boolean literals is represented as true or false.

Example,

[source,javascript]
----
true // true value
false // false value
----

==== 3.3.2 Integer literal

Integer literals are represented as integer with range from -(2b-1) to 2b-1-1 where b=32 or 64 it depending whether ZetScript is compiled for 32bits or 64bits. The integer value can be represented as decimal value, hexadecimal,binary or char format.

Example,

[source,javascript]
----
10; // decimal value
0x1a; // hexadecimal value
01001b; // binary value
'b'; // char value
----

Literal integer pre operators are the following,

[cols="1d,1m,2d,2a"]
|====
|Operator |Expression |Description |Example

|Negate
|-integer 
|Negated value
|
[source,javascript]
 -10
 
|Bitwise complement
|~integer 
|Invert all bits
|
[source,javascript]
~(00000011b) // 11111100b
|====

==== 3.3.3 Float literal

Float literals are represented as IEEE-754 floating point numbers in 32-bit or 64 bit it depending whether ZetScript is compiled for 32bits or 64bits. Float can be represented in decimal form or scientific notation form.

Example,

[source,javascript]
----
1.2 // integer and decimal form
2.0e-2 // cientific notation form
----

==== 3.3.4 String literal

String literal is represented as string within quotes (").

Example,

[source,javascript]
----
"this is a string"
----

=== 3.4 Variables

==== 3.4.1 Variable declaration

A variable is a type of container that is used to store a value in it. A variable is declared as *var* keyword.

Example,

[source,javascript]
----
var i; // declares i variable
----

==== 3.4.2 Variable

A variable is a kind of element that can hold a variable. Because ZetScript variables are _dynamically typed_, it can hold different type of values on its lifetime. A variable is declared as *var* and, by default, is initialized as *undefined* value (see 2.5.1). 

[source,javascript]
----
var i; // Declared variable 'i' with no inicialization (undefined value).
----

A variable can be initialized with a proper type value through '=' operator. The follow example initializes a variable with integer value
(see section 2.2),

[source,javascript]
----
var i=10; // Declared variable 'i' and initialized as integer value.
----

==== 3.4.2 Constant

A constant is a kind of element where its value is immutable on its in lifetime. A constant is declared as *const* and is mandatory to be initialized.

[source,javascript]
----
const NUM_ITEMS=10; // constant 'NUM_ITEMS' with value 10.
----

==== 3.4.3 Scope

In ZetScript we have two types of basic scopes.

* Global
* Local

A ZetScript makes easy the concept of global local scope. Basically, variables declared on the main script are global and the others declared within a [block footnote:[A block is a statement that starts with '{' and ends with '}']], are local.

Example,

[source,javascript]
----
// Declares *i* variable as global
var i;

// block starts here 
{	
	// Declare *j* variable as local (you can also access to i).
	var j;
}
// block ends here, so *j* variable doesn't exist anymore
----

=== 3.5 Types

ZetScript supports the following types,

* Undefined
* Null
* Integer
* Number
* Boolean
* String
* Vector
* Object
* Function

==== 3.5.1 Undefined type

Undefined type it defines a non initialized variable. A variable is instanced as _undefined_ once a its assings *undefined* value,

[source,javascript]
----
var a; // 'a' is undefined as default
var b=undefined; // assigns undefined value
----

==== 3.5.2 Null type

Null type it defines an empty or not valid variable. A variable is instanced as _null_ once a its assings *null* value,

[source,javascript]
----
var i=null;
----

==== 3.5.3 Integer type

Integer type it defines a integer variable with range from -(2b-1) to 2b-1-1 where b=32 or 64 it depending whether ZetScript is compiled for 32bits or 64bits. A variable is instanced as _integer_ once it assigns decimal, hexadecimal,binary or char value.

Example,

[source,javascript]
----
var a=10; // decimal value
var b=0x1a; // hexadecimal value
var c=01001b; // binary value
var d='b'; //  char value
----

*Integer operators*

Integer operators are applied on integer variables before or after is read. Integer operators are the following,

[cols="1d,1m,2d,2a"]
|====
|Operator |Expression |Description |Result

|Negate
|-variable 
|Negates its value
|
[source,javascript]
 var i=10;
 var j=-i; // j=-10
 
|Bitwise complement
|~variable 
|Invert all bits
|
[source,javascript]
 var i=00000011b;
 var j=~i; // j=11111100b or -4 decimal
|PreIncrement
|++variable 
|Increments FIRST and THEN evaluates
|
[source,javascript]
 var i=0;
 var j=++i; // j=1, i =1
 
|PostIncrement
|variable++ 
|Evaluates FIRST and THEN increments
| 
[source,javascript]
var i=0; 
var j=i++; // j=0; i=1

| Predecrement
| --variable 
|Decrements FIRST and THEN evaluates
| 
[source,javascript]
var i=0; 
var j=--i; // j=-1; i=-1

|Postdecrement
|variable--
|Evaluates FIRST and THEN decrements
|[source,javascript] 
var i=0; 
var j=i--;//j=0;i=-1;
|====

==== 3.5.4 Float type

Float type it defines a float variable represented as IEEE-754 floating point numbers in 32-bit or 64 bit it depending whether ZetScript is compiled for 32bits or 64bits. A variable is instanced as _float_ once it assigns a decimal or scientific value notation forms.

Example,

[source,javascript]
----
var a=1.2 // decimal form value
var b=2.0e-2 // cientific notation form value
----


*Float operators*

Float operators are applied on float variables before or after is read. Float operators are the following,


[cols="1d,1m,2d,2a"]
|====
|Operator |Expression |Description |Result
|Negate
|-variable 
|Evaluates negated variable
|
[source,javascript]
 var i=10.5;
 var j=-i; // j=-10.5

|PreIncrement 
|++variable 
|Increments FIRST and THEN evaluates
|
[source,javascript]
var i=0.5;
var j=++i; // j=1.5, i =1.5

|PostIncrement 
|variable++ 
|Evaluates FIRST and THEN increments
|
[source,javascript]
var i=0.5;
var j=i++; // j=0.5; i=1.5

|Predecrement 
|--variable 
|Decrements FIRST and THEN evaluates
|
[source,javascript]
var i=0.5;
var j=--i; // j=-0.5; i=-0.5

|Postdecrement 
|variable-- 
|Evaluates FIRST and THEN decrements
|
[source,javascript]
var i=0.5;
var j=i--;//j=0.5;i=-0.5;
|====

==== 3.5.5 Boolean type

Boolean type it defines a boolean variable represented as _true_ or _false_. A variable is instanced as _boolean_ once it assigns a boolean value.

Example,

[source,javascript]
----
var b=false;
----

==== 3.5.6 String type

String type it defines a string type represented as a sequence of chars. A variable is instanced as _string_ once it assigns a string value.

Example,

[source,javascript]
----
var s="this is a string";
----

===== 3.5.6.1 Member functions

String type provides the following set of member functions,

 * size()
 * eraseAt(_pos)
 * insertAt(_pos,_char)
 * clear()
 * replace(_old_str,_new_str)
 * split(_char|_str)
 * contains(_str)
 * indexOf(_char|_str)
 * startsWith(_str)
 * endsWith(_str)
 * substring(_str,_pos,_length)
 * append(_str)
 
*String::size()*

_String::size_ returns the length of the string

Example,

[source,javascript]
----
"hello world".size() // returns 11 
----

*String::eraseAt*

_String::eraseAt_ inserts additional characters into the string right before the character indicated by pos (or p):

Example,

[source,javascript]
----
"hello world".size() // returns 11 
----

*String::insertAt(_pos)*

Inserts additional characters into the string right before the character indicated by __pos_

Example,

[source,javascript]
----
var s1=
"hello world".size() // returns 11 
----

*String::clear*

*String::replace*

*String::split*

*String::contains*

*String::indexOf*

*String::startsWith*

*String::endsWith*

*String::substring*

*String::append*
 
====== 3.5.6.2 Static functions

String type provides the following set of static functions,

* format

===== 3.5.6.3 Operators

String type provides the following set of operators,

 * ==
 * +=

=== 3.5.7 Vector type

Vector type it defines a container type that stores multiple values in a unidimensional array. A variable is instanced as _vector_ once it assings a open/closed square brackets (i.e '[]' ), 

Example,

[source,javascript]
----
var v=[]; // empty vector
----

Variable instanced as _vector_ can also have initialized with a sequence of elementsseparated with coma (i.e ',') within square brackets,

Example,

[source,javascript]
----
var v=[1,"string",true,2.0]; // Vector with elements
----

To access element vector is done through integer as a index.

Example,

[source,javascript]
----
var v=[1,"this is a string",true,2.0]; // its has 4 elements where its index access exist in [0..3]
v[1]; // It access vector's second element (i.e "this is a string")
----

*Member functions*

Vector type provides the following set of member functions.

[cols="1m,1d,2a"]
|====
|Function |Description |Example
|size 
|It returns the number of current elements
|
[source,javascript]
var v=[1,2];
v.size(); // =2

|push 
|Adds value at the end of the vector
|
[source,javascript]
var v=[1,2];
v.push(3); //v=[1,2,3]

|pop 
|Returns the last value and removes it. 
|
[source,javascript]
var v=[1,2];
v.pop(); //=[2], v=[1]
|==== 


==== 3.5.8 Object type

An object type is a anonymous container type to store multiple values in attributes. The instantiation is done within a pair of curly brackets (i.e '{}'),

[source,javascript]
----
var t={};
----

Optionally we can init with some values with its attributes,

[source,javascript]
----
var t={
  i:1
 ,s:"this is a string"
 ,b:true
 ,f:2.0
};
----

To acces to its elements is done through the variable name followed by '.' and attribute name or attribute name as string within brackets (i.e ["attribute_name"] ),

[source,javascript]
----
var v_i=v.i; // get value 'i' by '.'
var v_i=v["i"]; // get value 'i' by '[]'
----

*Built-in functions*

Object type it has the following functions in order to manage struct at runtime,

[cols="1m,1d,2a"]
|====
|Function |Description |Example

|size 
|It returns the number of current elements 
|
[source,javascript
var v=[1,2];
v.size(); // =2

|add
|Adds an attribute
|
[source,javascript]
var s={};
v.add("a",0); // s={a:0}

|remove 
|Removes an attribute
|
[source,javascript]
var s={a:0};
v.remove("a"); // s={}
|====

==== 3.5.9 Function object

A function is an object that holds information about a function and is able to call it (see section 3.8.3 for more information)

Example,

[source,javascript]
----
function add(op1, op2){ // function that returns the sum of two vars.
return op1+op2;
}
var fun_obj = add; // stored function add reference to fun_obj
var j=fun_obj(2,3);// calls fun_obj (aka add) function. J=5
Another example by anonymous function,
var fun_obj = function (op1, op2){ // function object that returns the sum of two vars.
return op1+op2;
};
var j=fun_obj(2,3);// calls fun_obj (aka anonymous function). function. J=5
----

=== 3.6 Operations

ZetScript has the following type of expressions

* Arithmetic operations
* Relational operations
* Logical operations
* Bit operations

==== 3.6.1 Arithmetic expressions

The following operators it does evaluates arithmetic expressions,

[cols="1d,1m,2d,2a"]
|====
|Operator |Symbol |Description |Example
|Add 
|+
|It performs a add operation between two integer or number values or concatenates strings with other values
|
[source,javascript]
5+10; // = 15
1.5+6; // = 7.5
"string_"+1;// ="string_1"

|Subtract
|-
|It performs a sub operation between two integer or number values
|
[source,javascript]
10-5; // = 5
2.5-1;// = 1.5

|Multiply 
|* 
|It performs a multiplication between two integer or number values
|
[source,javascript]
10*5; //= 50
1.5*2;//= 3.0

|Divide 
|/ 
|It performs a division between two integer or number values
|
[source,javascript]
10/2; // = 5
3/2.0 // = 1.5

|Modulus 
|% 
|It performs a division between two integer or number values
|
[source,javascript]
3%2; //it results 1
10%2.5; // it results
|====

==== 3.6.2 Relational expressions

The following operators it does evaluates relational expressions,

[cols="1d,1m,2d,2a"]
|====
|Operator |symbol |Description |Example

|Equal 
|==
|Check whether two values are equal
|
[source,javascript]
 10==10;// = true
"hello"=="bye"; // = false

|Not equal 
|!= 
|Check whether two values are not equal
|
[source,javascript]
10!=10; // = false
"hello"!="bye"; // = true

|Less than 
|< 
|Checks whether first value is less than second value
|
[source,javascript]
10<20; // = true
20<10; // = false

|Greater than 
|> 
|Checks whether first value is greater than second value
|
[source,javascript]
10>20; // = false
20>10; // = true

|Less equal than 
| <= 
|Checks whether first value is less equal than second value
|
[source,javascript]
10<=10; //= true
11<=10; // = false

|Greater equal than 
|>= 
|Checks whether first value is greater equal than second value
|
[source,javascript]
10>=11; // = false
11>=10; // = true

|Instance of 
|instanceof 
|Checks if a value is instance of a type. 
|
[source,javascript]
0 instanceof int; //= true
"hello" instanceof int;//= false
|====

Note: You cannot mix different types for relational expressions. For example, doing a
relational expression with boolean and integer values is incompatible. 

==== 3.6.3 Logic expressions

Logic expressions are the ones that combines operations through boolean values,

[cols="1d,1m,2d,2a"]
|====
|Operator |symbol |Description |Example

|Logic And 
|&& 
|it performs an AND operation between two Boolean values
|
[source,javascript]
true && true;// = true
true&& false;// = false

|Logic Or 
| \|\|
|It performs an OR operation between two Boolean values
|
[source,javascript]
true \|\| false;// = true
false \|\| false;// = false

|Logic Not 
|! 
|Negates Boolean value
|
[source,javascript]
!true; // = false
!false; // = true
|====

==== 3.6.4 Binary expressions

Binary expressions are the ones that combines bit operations through integer values,

[cols="1d,1m,2d,2a"]
|====
|Operator |symbol |Description |Example

|Binary And 
|& 
|Performs binary AND operation between two integers
|
[source,javascript]
0xa & 0x2; // = 0x2
0xff & 0xf0; // = 0xf0

|Binary Or
|\|
|Performs binary OR operation between two integers
|
[source,javascript]
0xa \| 0x5; // = 0xf
0x1 \| 0xe; // = 0xf

|Binary Xor 
|^ 
|Performs binary XOR between two integers
|
[source,javascript]
0xa ^ 0xa; // = 0x0
0xa ^ 0x5; // = 0xf

|Binary shift left
|<< 
|Performs binary shift left
|
[source,javascript]
0x1 << 2; // = 0x4

|Binary shift right
|>> 
|Performs binary shift right 
|
[source,javascript]
0xff >> 1; // = 0x7f
|====

=== 3.6.5 Priority operations
Each operator it has priority of evaluation. ZetScript it has the following operator order priority,

*,/,%,!=,+,-,^,&,|,<<,>>,==,<=,>=,>,<,||,&&

For example this expression,

[source,javascript]
----
2+4*5; // will result 22
----

You can change the evaluation priority usign parenthesis.

For example,

[source,javascript]
----
(2+4)*5; // will result 36
---- 

=== 3.7 Conditionals

A conditional statement are used to perform different actions based on different conditions. In ZetScript we have the following conditional statement:

* Use if to specify a block of code to be executed, if a specified condition is true
* Use else to specify a block of code to be executed, if the same condition is false.
* Use ternary condition to have a short if/else statement into single statement.
* Use switch to specify manu alternative blocks of code to be executed

==== 3.7.1 The if statement
Use the if statement to specify a block of ZetScript code to be executed if a condition is 'true'.

Syntax,

[source,javascript]
----
if(condition){
	//Block of code to be executed if the condition is true
}
----

Example,

[source,javascript]
----
if(n < 10) {
	// do something if condition is true
}
----

==== 3.7.2 The else statement

Use the else statement to specify a block of code to be executed if the condition is 'false'.

Syntax,

[source,javascript]
----
if(n < 10) {
	// do something if condition is true
}else{
	// do something if condition is false
} 
----

==== 3.7.3 The if else statement

Use the else statement to specify a block of code to be executed if the condition is 'false'.

Syntax,

[source,javascript]
----
if(n < 10) {
 	// do something if condition is true
}else if(n < 20){
	// do something if condition is true
}else{
	// do something if none of above conditions are true
}
----

==== 3.7.4 Ternary condition

Use ternary condition to have a short if/else statement into single statement. It performs expression if the condition is true or the second expression if the condition is 'false'.

Syntax,

[source,javascript]
----
result = (condition)?first expression:2nd expression;
----

Example,

[source,javascript]
----
var j = 0>1? 0:1; // j = 1
----

==== 3.7.5 Switch

Use the switch statement to select one of many blocks of code to be executed.

Syntax,

[source,javascript]
----
switch(expression) {
	case value_0:
		code block
		break;
	case value_1:
		code block
		break;
	 	...
		case value_n
		default:
		code block
		break;
}
----

Example,

[source,javascript]
----
switch (n) {
	case 0:
		// do something if n==0
		break;
	case 1:
		// do something if n==1
		break;
	default:
		// do something if n!=0 && n!=1
		break;
}
----

Switch can have common code blocks in different conditions

Example,

[source,javascript]
----
switch (n) {
	case 0:
	case 1:
	 	// do something if n==0 or n==1
		break;
	case 2:
	case 3:
		// do something if n==2 or n==3
	break;
	default:
		// do something if n!=0 && n!=1 && n!=2 && n!=3
		break;
}
----

=== 3.8 Loops

ZetScript supports the following loop types,

* While Loop
* For Loop

==== 3.8.1 while

The while loop loops through a block of code as long as a specified condition is true.

Syntax,

[source,javascript]
----
while(condition){
	// code block to be executed
}
----

Example,

[source,javascript]
----
var i = 0;
while (i < 5){
	// do something until i==5
	i++;
} 
----

==== 3.8.2 do-while

do-while loop is always be executed at least once, even if the condition is false, because the code block is executed before the condition is tested:

Syntax,

[source,javascript]
----
do{
	// do-while body
} while (condition);
----

Example,

[source,javascript]
----
var i = 0;
do {
	// do something until i==5
	i++;
} while (i < 5);
----

==== 3.8.3 The For Loop

The for loop is often the tool you will use when you want to create a loop.

Syntax,

[source,javascript]
----
for(stament1;statment2;statment3){
	// code block to be executed
}
----

* Statement 1 is executed before the loop (the code block) starts. Normally you will use statement 1 to initialize the variable used in the loop (for example var i = 0).
* Statement 2 defines the condition for running the loop.
* Statement 3 is executed each time after the code block has been executed.

Example,

[source,javascript]
----
for(var i=0; i < 5; i++) {
	print("The number is "+i);
} 
----


=== 3.9 Functions

Function is a block of code to perform a particular task and is executed when in some part of the code it calls it.

==== 3.9.1 Function syntax

A JavaScript function is defined with the function keyword, followed by a name, followed by parentheses ().

Syntax,

[source,javascript]
----
function fun_name(arg1, arg2, ..., argn){
	// code to be executed
}
----

Example,

[source,javascript]
----
function add(op1, op2){
	return op1+op2;
}
----

==== 3.9.2 Call a function

The call of a function is done when in some part of the code it calls it as follow,

Syntax

[source,javascript]
----
fun_name(arg1, arg2, arg3,..., argN);
----

Note: If a function is called with less than N args the rest of arguments will remain undefined.

Example,

[source,javascript]
----

function add(op1,op2){
	return op1+op2;
}

var j=add(2,3); // calls add function. j=5
----

==== 3.9.3 Function object

A function can be stored in variables through its reference,

[source, zetscript]
function add(op1, op2){
return op1+op2;
}

var fun_obj = add; // stored function add reference to fun_obj
var j=fun_obj(2,3);// calls fun_obj (aka add) function. J=5


Also is possible to create function objects,

Syntax

[source, zetscript]
function(arg1, arg2, ..., argN){
// code to be executed.
};


Example,

[source, zetscript]
var add=function(op1, op2){
return op1+op2;
};
var j=add(2,5); // j=5

=== 3.10 Class

A class is a type of structure that contains variables and functions that operates with this variables. A class is defined in ZetScript using keyword class followed by the name of class. To access class variables within functions use the this keyword in order to access to variable or functions inside class. In a class we can find member functions (functions that affects to class variable) or static functions (helper function of generic purposes about the class type).

Example,

[source, zetscript]
class Test{
 // member variable
 var data1;
 // member function
 function function1 (a){
 this.data1 =a;
 print("function1:"+this.data1);
 return this.data1;
 }
 // static function that performs an add operation between two Test type objects
 function add_test (a,b){
 return a.data1+b.data1;
 }
};

==== 3.10.1 Post add function/variable member

In ZetScrip is possible to add more class member through "::" punctuator.

Example,

[source, zetscript]
// post declaration of variable member
var Test::data2;
// post declaration of function member
function Test::function2(){
 this.data2="a string";
}

==== 3.10.2 Instance class

To instance a class is done through the keyword new

Example,

[source, zetscript]
var t = new Test(); // Instantiate t as Test type.

==== 3.10.3 Accessing to class functions

To access class variables/functions is done through "." operator.

Example,

[source, zetscript]
var i=t.function1(2); // initializes data1 as 2 and return the value
print("data1 is: "+t.data1); // prints value of data1

==== 3.10.4 Constructor

Each time class is instanced, their member variables are undefined. var t = new Test(); // The a class Test is instanced but data1 and data2 are undefined.

[source, zetscript]
print("data1:"+t.data1); //  prints: data1:undefined"

The constructor is a function that is invoked automatically and with aim to initialize all member variables. To the define a constructor we have to define a function member with same name as the Class.

Example,

[source, zetscript]
class Test{
 var data1;
 // Constructor function
 function Test(){
 this.data1 =10; // instantiate data1 as integer
 }
}
var t = new Test(); // Instantiate t as Test type. Now, member variables are instanced.
print("data1:"+t.data1); //  prints "data1: 10"

==== 3.10.5 Inheritance

ZetScript supports inheritance through ":" punctuator after the name of the class followed the class name to be extended. The new extended class will inheritance all variable/functions members from base class.

Example,

[source, zetscript]
class TestExtended: Test{
 var data3;
 function function3(){
 this.data3=this.data1+this.function1(10);
 }
};

===== 3.10.5.1 Call parent functions (super keyword)

The extended class can call parent functions through super keyword.

Example,

[source, zetscript]
class TestExtended extends Test{
 function1(a){
 var t=super(a); // it calls Test::function1(2)
 this.data1+=t; // Now data1=5+2 = 7
 print("ext function1:"+this.data1);
 return this.data1+a;
 }
 function3(){
 this.data3=this.data1+this.function1(5);
 print("ext function3:"+this.data3);
 }
}; 


=== 3.11 Metamethods
Metamethods are special functions members that links with operators seen on section section 3.6. ZetScript metamethods can be static or member function footnote:[ On script side, static function is defined as member function, but user should not access on variable/function members as well it happens on c++ static function.] depending whether the operation affects or not the object itself. 

ZetScript supports the following metamethods:

* _equ
* _nequ
* _lt
* _lte
* _not
* _gt
* _gte
* _neg
* _btw
* _add
* _sub
* _div
* _mul
* _mod
* _and
* _or
* _xor
* _shl
* _shr
* _set
* _add_set
* _sub_set
* _mul_set
* _div_set
* _mod_set
* _and_set
* _or_set"
* _xor_set
* _shl_set
* _shr_set
* _toString
* _post_inc
* _post_dec
* _pre_inc
* _pre_dec
* _in



==== 3.10.1 _equ (aka ==)

@Description: Performs relational equal operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if equal, false otherwise.

Example how to use _equ metamethod within script class,

class MyNumber{
 MyNumber(_n){
 this.num=_n;
 }
 _equ(op1, op2){
 return op1.num==op2.num;
 }
};

var n1 = new MyNumber (1), n2=new MyNumber (1);

if(n1==n2){ // we use here the metamethod ==
 print("n1 ("+n1.num+") is equal to n2 ("+n2.num+")");
} 


==== 3.10.2 _nequ (aka !=)

@Description: Performs relational not equal operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if not equal, false otherwise.

Example how to use _nequ metamethod within script class,

class MyNumber{
 MyNumber(_n){
 this.num=_n;
 }
 _nequ(op1, op2){
 return op1.num!=op2.num;
 }
};

var n1 = new MyNumber (1), n2=new MyNumber (0);
if(n1!=n2){
 print("n1 ("+n1.num+") is not equal to n2 ("+n2.num+")");
} 


==== 3.10.3 _lt (aka <)

@Description: Performs relational less equal operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if less equal, false otherwise.

Example how to use _lt metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _lt(op1, op2){
 return op1.num<op2.num;
 }
};

var n1 = new MyNumber (0), n2=new MyNumber (1);
if(n1<n2){
 print("n1 ("+n1.num+") is less than n2 ("+n2.num+")");
} 

==== 3.10.4 _lte (aka <=)

@Description: Performs relational less equal operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if less equal, false otherwise.

Example how to use _lte metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _lte(op1, op2){
 return op1.num<=op2.num;
 }
};

var n1 = new MyNumber (1), n2=new MyNumber (1);
if(n1<=n2){
 print("n1 ("+n1.num+") is less equal than n2 ("+n2.num+")");
} 

==== 3.10.5 _gt (aka >)

@Description: Performs relational greater operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if greater, false otherwise.


Example how to use _gt metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _gt(op1, op2){
 return op1.num>op2.num;
 }
};

var n1 = new MyNumber (1), n2=new MyNumber (0);
if(n1>n2){
 print("n1 ("+n1.num+") is greater than n2 ("+n2.num+")");
}

==== 3.10.6 _gte (aka >=)

@Description: Performs relational greater equal operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : true if greater equal, false otherwise.

Example how to use _gte metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _gte(op1, op2){
 return op1.num>=op2.num;
 }
};

var n1 = new MyNumber (1), n2=new MyNumber (1);
if(n1>=n2){
 print("n1 ("+n1.num+") is greater equal than n2 ("+n2.num+")");
} 


==== 3.10.7 static _not (aka !)

@Description: Performs a not operation.
@Param1 : Object custom class type.
@Returns : A Boolean type as a result of not operation.

Example how to use _not metamethod within script class,

class MyBoolean{
 var b;

 function MyBoolean(_b){
 this.b=_b;
 }
 function _not(_op){
 return !_op.b;
 }
};

var b = new MyBoolean (false);
if(!b){
 print("b was false");
} 

==== 3.10.8 _neg (aka -)

@Description: Performs negate operation.
@Param1 : operand to negate.
@Returns : A new object custom class type with result of negate operation.

Example how to use _neg metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _neg(op1){
 return new MyNumber(-op1.num);
 }
};

var n1 = new MyNumber (1);
var n2 = -n1;
print("neg of n1 ("+n1.num+") is ("+n2.num+")"); 

==== 3.10.9 _add (aka +)

@Description: Performs add operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result add operation.

Example how to use _add metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _add(op1,op2){
 return new MyNumber(op1.num+op2.num);
 }
};

var n1 = new MyNumber (20);
var n2 = new MyNumber (10);
var n3 =n1+n2;

print("n1 ("+n1.num+") n2 ("+n2.num+") = "+n3.num);

==== 3.10.10 _div (aka /)

@Type: Static
@Description: Performs divide operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result divide
operation.

Example how to use metamethod _div within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _div(op1,op2){
 return new MyNumber(op1.num/op2.num);
 }
};

var n1 = new MyNumber (20);
var n2 = new MyNumber (10);
var n3 =n1/n2;
print("n1 ("+n1.num+") / n2 ("+n2.num+") = "+n3.num);


==== 3.10.11 _mul (aka *)

@Type: Static
@Description: Performs multiply operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result multiply operation.

Example how to use _mul metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _mul(op1,op2){
 return new MyNumber(op1.num*op2.num);
 }
};

var n1 = new MyNumber (20);
var n2 = new MyNumber (10);
var n3 =n1*n2;
print("n1 ("+n1.num+") * n2 ("+n2.num+") = "+n3.num);

==== 3.10.12 _mod (aka %)

@Description: Performs modulus operation.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result modulus operation.

Example how to use _mod metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _mod(op1,op2){
 return new MyNumber(op1.num%op2.num);
 }
};

var n1 = new MyNumber (20);
var n2 = new MyNumber (15);
var n3 =n1%n2;
print("n1 ("+n1.num+") % n2 ("+n2.num+") = "+n3.num);

==== 3.10.13 _and (aka &)

@Description: Performs binary and operation between two integer
operands.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result of binary and operation.

Example how to use _and metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _and(op1,op2){
 return new MyNumber(op1.num&op2.num);
 }
};

var n1 = new MyNumber (0xff);
var n2 = new MyNumber (0x0f);
var n3 =n1&n2;
print("n1 ("+n1.num+") & n2 ("+n2.num+") = "+n3.num); 

==== 3.10.14 _or (aka |)

@Description: Performs binary or operation between two integer
operands.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result of binary or operation.

Example how to use _or metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _or(op1,op2){
 return new MyNumber(op1.num|op2.num);
 }
};

var n1 = new MyNumber (0xf0);
var n2 = new MyNumber (0x0f);
var n3 =n1|n2;
print("n1 ("+n1.num+") | n2 ("+n2.num+") = "+n3.num);

==== 3.10.15_xor (aka ^)

@Description: Performs a binary xor operation between two integer
operands.
@Param1 : 1st operand.
@Param2 : 2nd operand.
@Returns : A new object custom class type with result of binary xor operation.

Example how to use _xor metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _xor(op1,op2){
 return new MyNumber(op1.num^op2.num);
 }
};
var n1 = new MyNumber (0xf1);
var n2 = new MyNumber (0x0f);
var n3 =n1^n2;
print("n1 ("+n1.num+") ^ n2 ("+n2.num+") = "+n3.num);

==== 3.10.16 _shl (aka <<)

@Description: Performs shift left operation.
@Param1 : Variable to apply shift left.
@Param2 : Tells number shifts to the left.
@Returns : A new object custom class type with n shifts left operation.

Example how to use _shl metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _shl(op1, n_shifts){
 return new MyNumber(op1.num<< n_shifts);
 }
};

var n1 = new MyNumber (0x1);
var n2 = n1 << 3;
print("n1 ("+n1.num+") << 3 = "+n2.num);


==== 3.10.17 _shr (aka >>)

@Description: Performs shift right operation.
@Param1 : Variable to apply shift right.
@Param2 : Tells number shifts to the right.
@Returns : A new object custom class type with n shifts right operation.

Example how to use _shr metamethod within script class,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _shr(op1,n_shifts){
 return new MyNumber(op1.num>>n_shifts);
 }
};

var n1 = new MyNumber (0xf);
var n2 = n1 >> 2;
print("n1 ("+n1.num+") >> 2 = "+n2.num);

==== 3.10.19 _set (aka =)

@Description: Performs a set operation6.
@Param1 : Source variable to set.
@Returns : None.

We present a simple example how to use set metamethod within script class. In the set metamethod we can filter which type of parameter input is to perform the right operation and stop execution with error function if is required.

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 } 
 function _set(v){
 if(v instanceof int){
 this.num = v;
 }else if(v instanceof MyNumber){
 this.num = v.num;
 }else{
 error("parameter not supported");
 }
 }
};

var n1 = new MyNumber (10);
var n2 = new MyNumber (20);
var n3; //  n3 is undefined!
n3 = n2; //  it assigns n2 pointer.
print("n3:"+n3.num);
n3=n1; //  n3.num = n2.num = n1.num.
print("n3:"+n3.num);
n3=50; //  n3.num = n2.num = 10.
print("n3:"+n3.num);
n3=false; //  stops execution with error "parameter not supported".

6
If variable is undefined ZetScript will assign reference object, in the case is not
defined it will do a set operation (if it is implemented). 


=== 3.10.20 Mixing operand types

Working with metamethods might have situations where you are passing different type parameters. You can pass the object type, where metamethod function is implemented, or other type of parameters like integer, string, etc.The following example performs a sums of a combination of object, integers or floats.

var num1= new MyNumber(1), num2=new MyNumber(2);
var num3= 1.0 + num1 + 6 + 1 + 10.0 + num2 + 10 + num1 + num2;

The expression cannot be performed with only objects as we have been shown in the last sections. You can use instanceof operator to check each type of argument and perform the needed operation.

We present an example for _add metamethod function that implements a support to operate with MyNumber object, integer or float. Other types will cause a execution
error.

Example,

class MyNumber{
 var num;
 function MyNumber(_n){
 this.num=_n;
 }
 function _add(op1,op2){
 var aux1, aux2;
 if(op1 instanceof MyNumber){
 aux1=op1.num;
 }else if(op1 instanceof int || op1 instanceof number){
 aux1=op1;
 }else{
 error("arg op1 is not supported");
 }
 if(op2 instanceof MyNumber){
 aux2=op2.num;
 }else if(op2 instanceof int || op2 instanceof number){
 aux2=op2;
 }else{
 error("arg op2 is not supported ");
 }

 return new MyNumber(aux1+aux2);
 }
};

var n1 = new MyNumber (20);
var n2 = new MyNumber (10);
var n3 =1+n1+5+7+n2+10.0+7.0+10; // mix operation with MyNumber, integer and number


3.11 Properties

A property is a member that defines a set of metamethods that to operate with. 



