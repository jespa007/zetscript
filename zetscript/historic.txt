ZetScript


emmscripten example:

arguments:['var j=0;for(var i=0; i < 10000000; ++i){i*2;}'],

version 1.00.00
===============

-emmscriptem port.
-set/save state.
-memory manager
-fusion CALE + CALE.h into CVirtualMachine!
-CVirtualMachine can be an object (in a future).
-Solve Bug: Create function object and embedd tInfoRegisteredFunction into it. 
-Optimization: Create stack int/bool/float/string to make internal operations and only create Objects in '='

1. Reserve memory

enum
{
	BOOL_TYPE
	FLOAT_TYPE
	INT_TYPE
	OBJECT_TYPE
	MAX_TYPES
}

struct stack{
	string 		stack_string[MAX_STACK];
	int 		stack_int[MAX_STACK];
	bool 		stack_bool[MAX_STACK];
	float 		stack_float[MAX_STACK];
	tInfoObject	stack_object[MAX_STACK]; //
	
	...
	
	int stack_index[MAX_TYPES][MAX_PUSH];

	int current_push[MAX_TYPES];
	
	int current_index;
	
	push_int(){ // push int + save into current instruction bank...
		+1
				
	}
	
	push(){ // save all indexes ...

	}
	
	pop(){ // restore all indexes ...

	}
}

stack_string[MAX_STACK]
stack_bool[MAX_STACK]
stack_float[MAX_STACK]
stack_script_var[MAX_STACK]

stack_primtive_var[MAX_STACK];



Example of use,

2. On each starting expression save current index.

stating_index = current_index;

// push example

3. On each new instruction do that
 
if(stating_index +1) > MAX_STACK){
	error
} 

...

instruction_stack[current_instruction]={&stack_int[starting_index+1],INTEGER};

4. At the end of expression restore index.

// pop example

//base_ptr_int (starting expression)






2. 

object.toString()+2 = LOAD OBJECT, CALL toString, ADD [],[]
2+2
fun()+2




version 1.00.00
===============

* Added null value (assign as undefined internally).
* Added shared pointer management.
* Erased factory folder. All classes are registered through ClassFactory.
* load/save json structure thorug C/script interfaces.
* added "new/class/this" keyword feature (both c/script functionallity). 


version 1.00.00
===============

Exit version