/*
 *  This file is distributed under the MIT License.
 *  See LICENSE file for details.
 */
#define PTR_FUNCTION_VOID_PARAM1(f) ((void (*)(zs_int))(f))
#define PTR_FUNCTION_VOID_PARAM2(f) ((void (*)(zs_int,zs_int))(f))
#define PTR_FUNCTION_VOID_PARAM3(f) ((void (*)(zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_VOID_PARAM4(f) ((void (*)(zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_VOID_PARAM5(f) ((void (*)(zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_VOID_PARAM6(f) ((void (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_VOID_PARAM7(f) ((void (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_VOID_PARAM8(f) ((void (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_VOID_PARAM9(f) ((void (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_VOID_PARAM10(f) ((void (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))

#define PTR_FUNCTION_RET_PARAM1(f) ((zs_int (*)(zs_int))(f))
#define PTR_FUNCTION_RET_PARAM2(f) ((zs_int (*)(zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_PARAM3(f) ((zs_int (*)(zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_PARAM4(f) ((zs_int (*)(zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_PARAM5(f) ((zs_int (*)(zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_PARAM6(f) ((zs_int (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_PARAM7(f) ((zs_int (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_PARAM8(f) ((zs_int (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_PARAM9(f) ((zs_int (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_PARAM10(f) ((zs_int (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))

#define PTR_FUNCTION_RET_FLOAT_PARAM1(f) ((zs_float (*)(zs_int))(f))
#define PTR_FUNCTION_RET_FLOAT_PARAM2(f) ((zs_float (*)(zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_FLOAT_PARAM3(f) ((zs_float (*)(zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_FLOAT_PARAM4(f) ((zs_float (*)(zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_FLOAT_PARAM5(f) ((zs_float (*)(zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_FLOAT_PARAM6(f) ((zs_float (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_FLOAT_PARAM7(f) ((zs_float (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_FLOAT_PARAM8(f) ((zs_float (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_FLOAT_PARAM9(f) ((zs_float (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_FLOAT_PARAM10(f) ((zs_float (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))

#define PTR_FUNCTION_RET_BOOL_PARAM1(f) ((bool (*)(zs_int))(f))
#define PTR_FUNCTION_RET_BOOL_PARAM2(f) ((bool (*)(zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_BOOL_PARAM3(f) ((bool (*)(zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_BOOL_PARAM4(f)	((bool (*)(zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_BOOL_PARAM5(f) ((bool (*)(zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_BOOL_PARAM6(f) ((bool (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_BOOL_PARAM7(f) ((bool (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_BOOL_PARAM8(f) ((bool (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_BOOL_PARAM9(f) ((bool (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_BOOL_PARAM10(f) ((bool (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))

#define PTR_FUNCTION_RET_STRING_PARAM1(f) ((String (*)(zs_int))(f))
#define PTR_FUNCTION_RET_STRING_PARAM2(f) ((String (*)(zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_STRING_PARAM3(f) ((String (*)(zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_STRING_PARAM4(f) ((String (*)(zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_STRING_PARAM5(f) ((String (*)(zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_STRING_PARAM6(f) ((String (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_STRING_PARAM7(f) ((String (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_STRING_PARAM8(f) ((String (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_STRING_PARAM9(f) ((String (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))
#define PTR_FUNCTION_RET_STRING_PARAM10(f) ((String (*)(zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int,zs_int))(f))

namespace zetscript{

	ScriptFunction * vm_find_native_function(
			VirtualMachine 		*	_vm
			,ScriptType 		*	_class_obj_type // if NULL is MainClass
			,ScriptFunction 	*	_script_function
			,Instruction 		* 	_instruction // call instruction
			,bool 					_is_constructor
			,const String 	& 	_symbol_to_find
			,StackElement 		*	_stk_arg
			,uint8_t	 			_n_args
	){

		// by default search over global functions...
		VirtualMachineData *data=(VirtualMachineData *)_vm->data;
		Instruction	*instruction=_instruction;
		ScriptFunction * ptr_function_found=NULL;
		String aux_string;
		int start_param=0;

		Symbol ** stk_elements_builtin_ptr= data->main_function_object->scope->symbol_functions->data();// vector of symbols
		size_t stk_elements_builtin_len=  data->main_function_object->scope->symbol_functions->length();// vector of symbols

		if(_class_obj_type != NULL){
			stk_elements_builtin_ptr=_class_obj_type->scope->symbol_functions->data();
			stk_elements_builtin_len=_class_obj_type->scope->symbol_functions->length();
		}

		for(int i = (int)(stk_elements_builtin_len-1); i>=0 && ptr_function_found==NULL; i--){ /* search all function that match symbol ... */
			ScriptFunction *irfs = NULL;
			start_param=1;

			ZS_VM_EXTRACT_FUNCTION_INFO

			aux_string=irfs->name;

			bool symbol_equals=aux_string == _symbol_to_find;

			if((symbol_equals && ((int)irfs->params_len == (_n_args+start_param)))){
				// Only check native functions
				if((irfs->properties & SCRIPT_FUNCTION_PROPERTY_NATIVE_OBJECT_REF)){ /* C! Must match all args...*/
					bool all_check=true; /*  check arguments types ... */
					ScriptTypeId arg_script_type_id=SCRIPT_TYPE_ID_INVALID;

					for( unsigned k = 0; k < _n_args && all_check;k++){ // ignore first parameter due expects zetscript
						StackElement *current_arg=&_stk_arg[k];
						arg_script_type_id=irfs->params[k+start_param].script_type_id;

						if(arg_script_type_id != SCRIPT_TYPE_ID_STACK_ELEMENT){
							//unsigned short var_type = STACK_ELEMENT_TYPE_PROPERTIES(current_arg->properties);
							if(current_arg->properties & STACK_ELEMENT_PROPERTY_PTR_STK){
								current_arg=(StackElement *)current_arg->value;
							}

							switch(current_arg->properties & MSK_STACK_ELEMENT_TYPE_PROPERTIES){
								default:
									aux_string="unknow";
									all_check=false;
									break;
								case STACK_ELEMENT_PROPERTY_INT:
									all_check=
											arg_script_type_id == SCRIPT_TYPE_ID_INT_PTR
										  ||arg_script_type_id == SCRIPT_TYPE_ID_INT
										  ||arg_script_type_id == SCRIPT_TYPE_ID_FLOAT_PTR;
									break;
								case STACK_ELEMENT_PROPERTY_FLOAT:
									all_check=arg_script_type_id == SCRIPT_TYPE_ID_FLOAT_PTR
											||arg_script_type_id == SCRIPT_TYPE_ID_FLOAT
											||arg_script_type_id == SCRIPT_TYPE_ID_INT_PTR
											||arg_script_type_id == SCRIPT_TYPE_ID_INT;
									break;
								case STACK_ELEMENT_PROPERTY_BOOL:
									all_check=arg_script_type_id == SCRIPT_TYPE_ID_BOOL_PTR;
									break;
								case STACK_ELEMENT_PROPERTY_FUNCTION|STACK_ELEMENT_PROPERTY_MEMBER_FUNCTION:
									all_check=arg_script_type_id == SCRIPT_TYPE_ID_MEMBER_FUNCTION_SCRIPT_OBJECT;
									break;
								case STACK_ELEMENT_PROPERTY_FUNCTION:
									all_check=arg_script_type_id == SCRIPT_TYPE_ID_SCRIPT_FUNCTION;
									break;
								// decoment to not allow nulls
								/*case STACK_ELEMENT_PROPERTY_NULL:
									all_check=false;
									break;*/
								case STACK_ELEMENT_PROPERTY_OBJECT:

									if(STACK_ELEMENT_IS_STRING_SCRIPT_OBJECT(current_arg)){
										all_check=arg_script_type_id == SCRIPT_TYPE_ID_STRING_SCRIPT_OBJECT; // if string object --> direct

										if(all_check==false){ // try native conversions
											all_check =
												(	arg_script_type_id == SCRIPT_TYPE_ID_STRING_PTR && current_arg->value!=0)
											  ||	arg_script_type_id == SCRIPT_TYPE_ID_CONST_CHAR_PTR;
										}
									}else{
										ScriptObject *var_object = NULL;
										var_object=((ScriptObject *)current_arg->value);
										aux_string=var_object->getScriptTypeName();
										all_check=var_object->getScriptType()->extendsFrom(arg_script_type_id);
									}
									break;
							}
						}
					}

					if(all_check){ /* we found the right function (set it up!) ... */
						ptr_function_found = irfs;
					}
				}

			}
		}

		if(ptr_function_found == NULL){
			String class_str=_class_obj_type==NULL?"":_class_obj_type->id != SCRIPT_TYPE_ID_CLASS_MAIN?_class_obj_type->name:"";
			int n_candidates=0;
			String str_candidates="";
			String function_name_not_found=
				class_str==""
				?
				_symbol_to_find
				:
				String::format("%s::%s",class_str.toConstChar(),_symbol_to_find.toConstChar());

			String args_str = "";
			/* get arguments... */
			for( unsigned k = 0; k < _n_args;k++){
				StackElement *current_arg=&_stk_arg[k];

				if(k>0){
					args_str.append(",");
				}

				//unsigned short var_type = STACK_ELEMENT_TYPE_PROPERTIES(current_arg->properties);
				if(current_arg->properties & STACK_ELEMENT_PROPERTY_PTR_STK){
					current_arg=(StackElement *)current_arg->value;
				}


				switch(current_arg->properties & MSK_STACK_ELEMENT_TYPE_PROPERTIES){

				default:
					aux_string=data->se->stackElementToStringTypeOf(current_arg);
					break;
				case STACK_ELEMENT_PROPERTY_INT:
					aux_string=k_str_int_type;
					break;
				case STACK_ELEMENT_PROPERTY_FLOAT:
					aux_string=k_str_float_type;
					break;
				case STACK_ELEMENT_PROPERTY_BOOL:
					aux_string=k_str_bool_type;
					break;
				case STACK_ELEMENT_PROPERTY_UNDEFINED:
					aux_string="undefined";
					break;
				case STACK_ELEMENT_PROPERTY_NULL:
					aux_string="null";
					break;
				case STACK_ELEMENT_PROPERTY_OBJECT:
					aux_string = ((ScriptObject *)current_arg->value)->getScriptType()->native_name;
					break;
				}

				args_str.append(Rtti::demangle(aux_string.toConstChar()));

				if(current_arg->properties == STACK_ELEMENT_PROPERTY_INT
				||current_arg->properties == STACK_ELEMENT_PROPERTY_FLOAT
				||current_arg->properties == STACK_ELEMENT_PROPERTY_BOOL
				){
					args_str.append(" [*] ");
				}
			}

			for(int i = (int)(stk_elements_builtin_len-1); i>=0 && ptr_function_found==NULL; i--){ /* search all function that match symbol ... */
				start_param=1;
				ScriptFunction *irfs=NULL;

				ZS_VM_EXTRACT_FUNCTION_INFO

				if((irfs->name == _symbol_to_find) && (irfs->properties & SCRIPT_FUNCTION_PROPERTY_NATIVE_OBJECT_REF)){

					if(n_candidates == 0){
						str_candidates.append("\tPossible candidates are:\n\n");
					}
					str_candidates.append("\t\t-");

					// type if not main
					if(_class_obj_type!=NULL && _class_obj_type->id != SCRIPT_TYPE_ID_CLASS_MAIN){
						str_candidates.append(_class_obj_type->name);
						str_candidates.append("::");
					}

					// writes script function interface
					// function name
					str_candidates.append(irfs->name);
					str_candidates.append("(");

					for(int a = 2; a < irfs->params_len; a++){
						if(a>2){
							str_candidates.append(",");
						}

						str_candidates+=Rtti::demangle(
							ZS_SCRIPT_TYPE_ID_TO_NATIVE_NAME(data->script_types_factory,irfs->params[a].script_type_id)
						);
					}

					// writes wrap

					str_candidates.append(")");

					str_candidates.append(" -- BIND FUNCTION AS --> ");

					str_candidates.append(Rtti::demangle(
							ZS_SCRIPT_TYPE_ID_TO_NATIVE_NAME(data->script_types_factory,irfs->return_script_type_id)
						)
					);

					str_candidates.append(" (*)");
					str_candidates.append("(");

					for(int a = 0; a < irfs->params_len; a++){
						if(a>0){
							str_candidates.append(",");
						}

						str_candidates.append(Rtti::demangle(
							ZS_SCRIPT_TYPE_ID_TO_NATIVE_NAME(data->script_types_factory,irfs->params[a].script_type_id)
							)
						);
					}
					str_candidates.append(")\n");

					n_candidates++;
				}
			}

			if(n_candidates == 0){
				ZS_VM_ERROR("Cannot call native %s '%s(%s)'. ScriptFunction not registered\n\n"
					,_is_constructor ? "constructor":class_str==""?"function":"member function"
					,function_name_not_found.toConstChar()
					,args_str.toConstChar()
				);

				return NULL;
			}
			else{
				ZS_VM_ERROR("Cannot call native %s '%s(%s)'\n\n%s"
					,_is_constructor ? "constructor":class_str==""?"function":"member function"
					,function_name_not_found.toConstChar()
					,args_str.toConstChar()
					,str_candidates.toConstChar()
				);
				return NULL;
			}
		}

		return ptr_function_found;
	}

	void  vm_execute_native_function(
			VirtualMachine 			*	_vm,
			const ScriptFunction 	*	_script_function,
			Instruction 			*	_instruction,
			ScriptObject  			* 	_this_object,
			const ScriptFunction 	*	_c_function,
			StackElement 			*	_stk_arg_c_function,
			uint8_t		 				_n_args
	){

		VirtualMachineData 	*	data=(VirtualMachineData *)_vm->data;
		zs_int  				fun_ptr = _c_function->ref_native_function_ptr;
		String 			str_aux;
		Instruction			*	instruction=_instruction;

		if((_c_function->properties & SCRIPT_FUNCTION_PROPERTY_NATIVE_OBJECT_REF)==0){
			ZS_VM_SET_USER_ERRORF(_vm,"Internal error: ScriptFunction not native");
			return;
		}

		ScriptTypeId return_script_type_id=_c_function->return_script_type_id;
		zs_int converted_param[ZS_MAX_NATIVE_FUNCTION_ARGS];
		zs_float aux_float[ZS_MAX_NATIVE_FUNCTION_ARGS];
		zs_int result=0;
		StackElement *stk_arg_current;
		data->current_call_c_function = _c_function;
		//int this_param=0;
		int idx_arg_start=1;
		uint8_t n_args=_n_args+1;


		// First param is zetscript instance reference always
		converted_param[0]=(zs_int)data->zs;


		// special case that this is passed in static ref function
		if(_this_object!=NULL){
			if(
				(_c_function->properties&SCRIPT_FUNCTION_PROPERTY_MEMBER_FUNCTION)
			){
				idx_arg_start++;
				n_args++;
				converted_param[1]=(zs_int)_this_object->getNativeObject();
			}else if(_this_object->script_type_id != SCRIPT_TYPE_ID_CLASS_MAIN){
				ZS_VM_ERROR_AND_RET("ScriptFunction '%s' is binded as STATIC at but it was acceded as member. You have to use STATIC access (i.e '%s::%s')"
						,_c_function->name.toConstChar()
						,_this_object->getScriptType()->name.toConstChar()
						,_c_function->name.toConstChar()
						,_c_function->name.toConstChar()
						);
			}
		}

		if(n_args>ZS_MAX_NATIVE_FUNCTION_ARGS){
			ZS_VM_ERROR_AND_RET("Max run-time args! (Max:%i Provided:%i)",ZS_MAX_NATIVE_FUNCTION_ARGS,n_args);
		}

		if((_c_function->properties & SCRIPT_FUNCTION_PROPERTY_NATIVE_OBJECT_REF) != SCRIPT_FUNCTION_PROPERTY_NATIVE_OBJECT_REF) {
			ZS_VM_ERROR_AND_RETF("ScriptFunction is not registered as C");
		}

		if(fun_ptr==0){
			ZS_VM_ERROR_AND_RETF("Null function");
		}

		if((int8_t)_c_function->params_len != (n_args)){
			ZS_VM_ERROR_AND_RET("Native function '%s' expects %i arguments but it passed %i arguments"
					,_c_function->name.toConstChar()
					,_c_function->params_len
					,n_args);
		}

		if(_c_function->params_len > ZS_MAX_NATIVE_FUNCTION_ARGS){
			ZS_VM_ERROR_AND_RET("Reached max param for C function (Current: %i Max Allowed: %i)",_c_function->params_len,ZS_MAX_NATIVE_FUNCTION_ARGS);
		}

		// convert parameters script to c...
		if(_stk_arg_c_function!=NULL){
			for(uint8_t  i = idx_arg_start; i < n_args;i++){

				stk_arg_current=&_stk_arg_c_function[i-idx_arg_start];
				if(stk_arg_current->properties & STACK_ELEMENT_PROPERTY_PTR_STK){
					stk_arg_current=((StackElement *)stk_arg_current->value);
				}

				// special case, function param is float and it has to convert to int
				if((stk_arg_current->properties & STACK_ELEMENT_PROPERTY_INT) && (_c_function->params[i].script_type_id == SCRIPT_TYPE_ID_FLOAT_PTR)){
					aux_float[i]=stk_arg_current->value;
					converted_param[i]=(zs_int)&aux_float[i];
				}else if(!data->se->stackElementTo(
					&_stk_arg_c_function[i-idx_arg_start]
					,_c_function->params[i].script_type_id
					,(zs_int *)&converted_param[i]
					,data->vm_error_description
				)){
					ZS_VM_ERROR_AND_RET("ScriptFunction '%s', param %i: %s",
						_c_function->name.toConstChar(),
						i,
						data->vm_error_description.toConstChar()
					);
				}
			}
		}

		if(_c_function->return_script_type_id == SCRIPT_TYPE_ID_VOID){ // getInstance()->getIdxClassVoid()){

			switch(n_args){
			case 1:
				PTR_FUNCTION_VOID_PARAM1(fun_ptr)(
					converted_param[0]
				);
				break;
			case 2:
				PTR_FUNCTION_VOID_PARAM2(fun_ptr)(
					converted_param[0]
					,converted_param[1]
				);
				break;
			case 3:
				PTR_FUNCTION_VOID_PARAM3(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
				);
				break;
			case 4:
				PTR_FUNCTION_VOID_PARAM4(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
					,converted_param[3]
				);
				break;
			case 5:
				PTR_FUNCTION_VOID_PARAM5(fun_ptr)(
					 converted_param[0]
					,converted_param[1]
					,converted_param[2]
					,converted_param[3]
					,converted_param[4]
				);
				break;
			case 6:
				PTR_FUNCTION_VOID_PARAM6(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
				);
				break;
			case 7:
				PTR_FUNCTION_VOID_PARAM7(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
					,converted_param[6]
				);
				break;
			case 8:
				PTR_FUNCTION_VOID_PARAM8(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
					,converted_param[6]
					,converted_param[7]
				);
				break;
			case 9:
					PTR_FUNCTION_VOID_PARAM9(fun_ptr)(
						converted_param[0]
						 ,converted_param[1]
						 ,converted_param[2]
						 ,converted_param[3]
						 ,converted_param[4]
						 ,converted_param[5]
						,converted_param[6]
						,converted_param[7]
						,converted_param[8]
					);
					break;
			case 10:
					PTR_FUNCTION_VOID_PARAM10(fun_ptr)(
						converted_param[0]
						 ,converted_param[1]
						 ,converted_param[2]
						 ,converted_param[3]
						 ,converted_param[4]
						 ,converted_param[5]
						,converted_param[6]
						,converted_param[7]
						,converted_param[8]
						,converted_param[9]
					);
					break;
			}

		}else if(_c_function->return_script_type_id == SCRIPT_TYPE_ID_BOOL){  // we must do a bool cast in order to get float return.
			switch(n_args){
			case 1:
				result=PTR_FUNCTION_RET_BOOL_PARAM1(fun_ptr)(
					converted_param[0]
				);
				break;
			case 2:
				result=PTR_FUNCTION_RET_BOOL_PARAM2(fun_ptr)(
					converted_param[0]
					,converted_param[1]
				);
				break;
			case 3:
				result=PTR_FUNCTION_RET_BOOL_PARAM3(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
				);
				break;
			case 4:
				result=PTR_FUNCTION_RET_BOOL_PARAM4(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
					,converted_param[3]
				);
				break;
			case 5:
				result=PTR_FUNCTION_RET_BOOL_PARAM5(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
					,converted_param[3]
					,converted_param[4]
				);
				break;
			case 6:
				result=PTR_FUNCTION_RET_BOOL_PARAM6(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
				);
				break;
			case 7:
				result=PTR_FUNCTION_RET_BOOL_PARAM7(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
					,converted_param[6]
				);
				break;
			case 8:
				result=PTR_FUNCTION_RET_BOOL_PARAM8(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
					,converted_param[6]
					,converted_param[7]
				);
				break;
			case 9:
				result=PTR_FUNCTION_RET_BOOL_PARAM9(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
					,converted_param[6]
					,converted_param[7]
					,converted_param[8]
				);
				break;
			case 10:
				result=PTR_FUNCTION_RET_BOOL_PARAM10(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
					,converted_param[6]
					,converted_param[7]
					,converted_param[8]
					,converted_param[9]
				);
				break;
			}
		}else if(_c_function->return_script_type_id == SCRIPT_TYPE_ID_FLOAT){ // we must do a float cast in order to get float return.
			zs_float float_aux=0;
			switch(n_args){
			case 1:
				float_aux=PTR_FUNCTION_RET_FLOAT_PARAM1(fun_ptr)(
					converted_param[0]
				);
				break;
			case 2:
				float_aux=PTR_FUNCTION_RET_FLOAT_PARAM2(fun_ptr)(
					converted_param[0]
					,converted_param[1]
				);
				break;
			case 3:
				float_aux=PTR_FUNCTION_RET_FLOAT_PARAM3(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
				);
				break;
			case 4:
				float_aux=PTR_FUNCTION_RET_FLOAT_PARAM4(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
					,converted_param[3]
				);
				break;
			case 5:
				float_aux=PTR_FUNCTION_RET_FLOAT_PARAM5(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
					,converted_param[3]
					,converted_param[4]
				);
				break;
			case 6:
				float_aux=PTR_FUNCTION_RET_FLOAT_PARAM6(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					,converted_param[5]
				);
				break;
			case 7:
				float_aux=PTR_FUNCTION_RET_FLOAT_PARAM7(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					,converted_param[5]
					,converted_param[6]
				);
				break;
			case 8:
				float_aux=PTR_FUNCTION_RET_FLOAT_PARAM8(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					,converted_param[5]
					,converted_param[6]
					,converted_param[7]
				);
				break;
			case 9:
				float_aux=PTR_FUNCTION_RET_FLOAT_PARAM9(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					,converted_param[5]
					,converted_param[6]
					,converted_param[7]
					,converted_param[8]
				);
				break;
			case 10:
				float_aux=PTR_FUNCTION_RET_FLOAT_PARAM10(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					,converted_param[5]
					,converted_param[6]
					,converted_param[7]
					,converted_param[8]
					,converted_param[9]
				);
				break;
			}

			ZS_FLOAT_COPY(&result,&float_aux);

		}else if(_c_function->return_script_type_id == SCRIPT_TYPE_ID_STRING){ // we must do a float cast in order to get float return.

			switch(n_args){
			case 1:
				str_aux=PTR_FUNCTION_RET_STRING_PARAM1(fun_ptr)(
					converted_param[0]
				);
				break;
			case 2:
				str_aux=PTR_FUNCTION_RET_STRING_PARAM2(fun_ptr)(
					converted_param[0]
					,converted_param[1]
				);
				break;
			case 3:
				str_aux=PTR_FUNCTION_RET_STRING_PARAM3(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
				);
				break;
			case 4:
				str_aux=PTR_FUNCTION_RET_STRING_PARAM4(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
					,converted_param[3]
				);
				break;
			case 5:
				str_aux=PTR_FUNCTION_RET_STRING_PARAM5(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
					,converted_param[3]
					,converted_param[4]
				);
				break;
			case 6:
				str_aux=PTR_FUNCTION_RET_STRING_PARAM6(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					,converted_param[5]
				);
				break;

			case 7:
				str_aux=PTR_FUNCTION_RET_STRING_PARAM7(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					,converted_param[5]
					,converted_param[6]
				);
				break;
			case 8:
				str_aux=PTR_FUNCTION_RET_STRING_PARAM8(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					,converted_param[5]
					,converted_param[6]
					,converted_param[7]
				);
				break;
			case 9:
				str_aux=PTR_FUNCTION_RET_STRING_PARAM9(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					,converted_param[5]
					,converted_param[6]
					,converted_param[7]
					,converted_param[8]
				);
				break;
			case 10:
				str_aux=PTR_FUNCTION_RET_STRING_PARAM10(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					,converted_param[5]
					,converted_param[6]
					,converted_param[7]
					,converted_param[8]
					,converted_param[9]
				);
				break;
			}

			// it pass as String reference (i.e String)
			result=(zs_int)&str_aux;

		}else{ // generic pointer or int

			switch(n_args){
			case 1:
				result=PTR_FUNCTION_RET_PARAM1(fun_ptr)(
					converted_param[0]
				);
				break;
			case 2:
				result=PTR_FUNCTION_RET_PARAM2(fun_ptr)(
					converted_param[0]
					,converted_param[1]
				);
				break;
			case 3:
				result=PTR_FUNCTION_RET_PARAM3(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
				);
				break;
			case 4:
				result=PTR_FUNCTION_RET_PARAM4(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
					,converted_param[3]
				);
				break;
			case 5:
				result=PTR_FUNCTION_RET_PARAM5(fun_ptr)(
					converted_param[0]
					,converted_param[1]
					,converted_param[2]
					,converted_param[3]
					,converted_param[4]
				);
				break;
			case 6:
				result=PTR_FUNCTION_RET_PARAM6(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
				);
				break;
			case 7:
				result=PTR_FUNCTION_RET_PARAM7(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
					,converted_param[6]
				);
				break;
			case 8:
				result=PTR_FUNCTION_RET_PARAM8(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
					,converted_param[6]
					,converted_param[7]
				);
				break;
			case 9:
				result=PTR_FUNCTION_RET_PARAM9(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
					,converted_param[6]
					,converted_param[7]
					,converted_param[8]
				);
				break;
			case 10:
				result=PTR_FUNCTION_RET_PARAM10(fun_ptr)(
					converted_param[0]
					 ,converted_param[1]
					 ,converted_param[2]
					 ,converted_param[3]
					 ,converted_param[4]
					 ,converted_param[5]
					,converted_param[6]
					,converted_param[7]
					,converted_param[8]
					,converted_param[9]
				);
				break;
			}
		}

		// check for return values through stack

		*data->vm_stk_current++=data->se->toStackElement(result,return_script_type_id);

		StackElement *sf_call_stk_return=(_stk_arg_c_function+_n_args); // +1 points to starting return...
		int sf_call_n_returned_arguments_from_function=data->vm_stk_current-sf_call_stk_return;


		// return all elements in reverse order in order to get right assignment ...
		// reverse returned items
		for(int i=0; i<(sf_call_n_returned_arguments_from_function>>1); i++){
			StackElement tmp=sf_call_stk_return[sf_call_n_returned_arguments_from_function-i-1];
			sf_call_stk_return[sf_call_n_returned_arguments_from_function-i-1]=sf_call_stk_return[i];
			sf_call_stk_return[i]=tmp;
		}
	}
}
