/*
 *  This file is distributed under the MIT License.
 *  See LICENSE file for details.
 */

#pragma once


//#define ZS_IDX_INSTRUCTION_OP2_UNDEFINED				-1
//#define ZS_IDX_INSTRUCTION_OP2_SOLVE_AT_RUNTIME		-2
//#define ZS_IDX_INSTRUCTION_OP2_CONSTRUCTOR					-3
#define ZS_IDX_INSTRUCTION_OP2_THIS							-4
//#define ZS_IDX_INSTRUCTION_OP2_CONSTRUCTOR_NOT_FOUND	-5
#define ZS_IDX_INSTRUCTION_JMP_BREAK						-6
#define ZS_IDX_INSTRUCTION_JMP_CONTINUE						-7
#define ZS_IDX_INSTRUCTION_OP2_RETURN_ALL_STACK				-10



// properties shared by compiler + instruction ..
typedef enum:unsigned short {

	INSTRUCTION_PROPERTY_USE_PUSH_STK				=0x0001,	// for create and store member
	INSTRUCTION_PROPERTY_ILOAD_K					=0x0002,
	INSTRUCTION_PROPERTY_ILOAD_R					=0x0004,
	INSTRUCTION_PROPERTY_ILOAD_R_ACCESS_LOCAL		=0x0008,   // for register access type
	INSTRUCTION_PROPERTY_ILOAD_R_ACCESS_THIS_MEMBER	=0x0010,   // for register access type
	INSTRUCTION_PROPERTY_ILOAD_KR					=0x0020,
	INSTRUCTION_PROPERTY_ILOAD_RK					=0x0040,
	INSTRUCTION_PROPERTY_ILOAD_RR					=0x0080,
	INSTRUCTION_PROPERTY_ZS_INT						=0x0100,
	INSTRUCTION_PROPERTY_ZS_FLOAT					=0x0200,
	INSTRUCTION_PROPERTY_BOOL						=0x0400,
	INSTRUCTION_PROPERTY_STRING						=0x0800

}InstructionProperty;




// PRE/POST OP
/*#define INSTRUCTION_PROPERTY_PRE_INC					(0x1<<BIT_INSTRUCTION_PROPERTY_PRE_INC) // ++
#define INSTRUCTION_PROPERTY_POST_INC					(0x1<<BIT_INSTRUCTION_PROPERTY_POST_INC) // ++
#define INSTRUCTION_PROPERTY_PRE_DEC					(0x1<<BIT_INSTRUCTION_PROPERTY_PRE_DEC) // --
#define INSTRUCTION_PROPERTY_POST_DEC					(0x1<<BIT_INSTRUCTION_PROPERTY_POST_DEC) // --
#define INSTRUCTION_PROPERTY_PRE_NEG_OR_NOT				(0x1<<BIT_INSTRUCTION_PROPERTY_PRE_NEG_OR_NOT)  // ! or neg
#define INSTRUCTION_PROPERTY_PRE_POST_OP				(((0x1<<(BIT_INSTRUCTION_PROPERTY_PRE_POST_OP-BIT_INSTRUCTION_PROPERTY_PRE_INC))-1)<<(BIT_INSTRUCTION_PROPERTY_PRE_INC))
#define GET_INSTRUCTION_PROPERTY_PRE_POST_OP(prop)		((prop)&INSTRUCTION_PROPERTY_PRE_POST_OP)
#define HAS_PRE_POST_INC_DEC_OP(prop)						(((INSTRUCTION_PROPERTY_PRE_INC|INSTRUCTION_PROPERTY_POST_INC|INSTRUCTION_PROPERTY_PRE_DEC|INSTRUCTION_PROPERTY_POST_DEC)&prop)!=0)*/

//#define INSTRUCTION_PROPERTY_PRE						(INSTRUCTION_PROPERTY_PRE_INC|INSTRUCTION_PROPERTY_PRE_DEC|INSTRUCTION_PROPERTY_PRE_NEG_OR_NOT)
//#define INSTRUCTION_PROPERTY_POST						(INSTRUCTION_PROPERTY_POST_INC|INSTRUCTION_PROPERTY_POST_DEC)

//#define	INSTRUCTION_PROPERTY_PRE_NEG 					(0x1<<BIT_INSTRUCTION_PROPERTY_PRE_NEG)
/*
#define	INSTRUCTION_PROPERTY_ILOAD_R_ACCESS_LOCAL			(0x1<<BIT_INSTRUCTION_PROPERTY_ILOAD_R_ACCESS_LOCAL) // LOCAL,   // by default
#define	INSTRUCTION_PROPERTY_ILOAD_R_ACCESS_THIS_MEMBER		(0x1<<BIT_INSTRUCTION_PROPERTY_ILOAD_R_ACCESS_THIS_MEMBER) // THIS,   // by default*/
//#define INSTRUCTION_PROPERTY_ACCESS_TYPE_THIS			(0x1<<BIT_INSTRUCTION_PROPERTY_ACCESS_TYPE_THIS)
//#define INSTRUCTION_PROPERTY_ACCESS_TYPE_FIELD			(0x1<<BIT_INSTRUCTION_PROPERTY_ACCESS_TYPE_FIELD)
//#define INSTRUCTION_PROPERTY_ACCESS_TYPE_VECTOR			(0x1<<BIT_INSTRUCTION_PROPERTY_ACCESS_TYPE_VECTOR)
//#define INSTRUCTION_PROPERTY_SCOPE_TYPE					(((0x1<<(BIT_INSTRUCTION_PROPERTY_ACCESS_TYPE_LAST-BIT_INSTRUCTION_PROPERTY_ACCESS_TYPE_FIRST))-1)<<(BIT_INSTRUCTION_PROPERTY_ACCESS_TYPE_FIRST))

//#define GET_INSTRUCTION_PROPERTY_SCOPE_TYPE(prop)		((prop)&INSTRUCTION_PROPERTY_SCOPE_TYPE)

// BYTE_CODE_CALL TYPE
/*#define INSTRUCTION_PROPERTY_USE_PUSH_STK			(0x1 << BIT_INSTRUCTION_USE_PUSH_STK)

#define INSTRUCTION_PROPERTY_ILOAD_K					(0x1 << BIT_INSTRUCTION_PROPERTY_ILOAD_K)
#define INSTRUCTION_PROPERTY_ILOAD_R					(0x1 << BIT_INSTRUCTION_PROPERTY_ILOAD_R)
#define INSTRUCTION_PROPERTY_ILOAD_KR					(0x1 << BIT_INSTRUCTION_PROPERTY_ILOAD_KR)
#define INSTRUCTION_PROPERTY_ILOAD_RK					(0x1 << BIT_INSTRUCTION_PROPERTY_ILOAD_RK)
#define INSTRUCTION_PROPERTY_ILOAD_RR					(0x1 << BIT_INSTRUCTION_PROPERTY_ILOAD_RR)

//#define INSTRUCTION_PROPERTY_NEXT_FIELD_LOAD			(0x1 << BIT_INSTRUCTION_PROPERTY_NEXT_FIELD_LOAD)

//#define INSTRUCTION_PROPERTY_POP_TWO					(0x1 << BIT_INSTRUCTION_PROPERTY_POP_TWO)

#define INSTRUCTION_PROPERTY_ZS_INT						(0x1 << BIT_INSTRUCTION_PROPERTY_ZS_INT)
#define INSTRUCTION_PROPERTY_ZS_FLOAT					(0x1 << BIT_INSTRUCTION_PROPERTY_ZS_FLOAT)
#define INSTRUCTION_PROPERTY_BOOL						(0x1 << BIT_INSTRUCTION_PROPERTY_BOOL)
#define INSTRUCTION_PROPERTY_STRING						(0x1 << BIT_INSTRUCTION_PROPERTY_STRING)*/

#define INSTRUCTION_PROPERTY_ILOAD						(INSTRUCTION_PROPERTY_ILOAD_K|INSTRUCTION_PROPERTY_ILOAD_R|INSTRUCTION_PROPERTY_ILOAD_KR|INSTRUCTION_PROPERTY_ILOAD_RK|INSTRUCTION_PROPERTY_ILOAD_RR)

#define INSTRUCTION_CONST_TO_STK_CONST_PROPERTY(properties)\
	 (properties) & INSTRUCTION_PROPERTY_ZS_INT ? STK_PROPERTY_ZS_INT \
	:(properties) & INSTRUCTION_PROPERTY_BOOL ? STK_PROPERTY_BOOL \
	:(properties) & INSTRUCTION_PROPERTY_ZS_FLOAT ? STK_PROPERTY_ZS_FLOAT \
	:(properties) & INSTRUCTION_PROPERTY_STRING ? STK_PROPERTY_PTR_STK \
	:0


namespace zetscript{

	#pragma pack(push, 1)


	struct Instruction {

		ByteCode byte_code;
		unsigned char value_op1;
		zs_int value_op2;
		unsigned short properties;

		Instruction();

		Instruction(ByteCode _byte_code
		 ,unsigned char _value_op1=ZS_IDX_UNDEFINED
		 ,zs_int _value_op2=ZS_IDX_UNDEFINED
		 ,unsigned short _properties=0
		 );

		std::string getConstantString();
		zs_float getConstantFloat();
		bool isConstant();

		std::string getConstantValueOp2ToString();


	};

	#pragma pack(pop)

	struct InstructionSourceInfo {

		const char * file;
		short line;
		std::string * ptr_str_symbol_name; // should be deallocated

		InstructionSourceInfo(){
			ptr_str_symbol_name=NULL;
			file="unknow_file";
			line=-1;

		}

		InstructionSourceInfo(const char * _file, short _line,std::string *_ptr_str_symbol_name=NULL){
			file=_file;
			line=_line;
			ptr_str_symbol_name=_ptr_str_symbol_name;
		}
	};


	typedef Instruction *PtrInstruction;

}
