> implement vector::_toString
> implement struct::_toString
> implement class::_toString 


>Clean code. 
>Test save/restore.
>Remove memory leaks.

> cmake: Add install feature.
> cmake: Add test features
 
> test arithmetic file (need reimplement %)
> test binary file
> test ternary file
> test if-else file
> test for file
> test while file
> test switch file
> test function file
> test metamethod file (test all override ops. implement _toString metamethod (override for vector & struct))
> test struct file
> test vector file
> test class file
> test c file
  -test boolean op and expected result.
  -test arithmetic op and expected result. 
  -test calling script function from c and viceversa.
  -test class with c binding
  -test class operators with c binding
  -save/restore state
  -calling script function from C

> Metamethods or C++ call functions fails when it calls from function with different signatures. Example.
  test print error
    
    From C++
    
    class CNumber{
    	float n;
    	
    	...
    	
    	// Metamethods...
    	CNumber * _add(CNumber *n1, int n2);
    	CNumber * _add(CNumber *n1, float n2);
    	
    	...
    	
    }
    
    // In script.
    
    
    function getSumNumber(a1, a2){
    	return a1+a2;
    }
    
    
    var n=new CNumber(0);
    
    ...
    
    getSumNumber(n,0);
    
    ...
    
    getSumNumer(n,1.0); <-- it fails because the first time the _add with integer signature was assigned ..
    
    
    Solutions:
    
    1. Find the right function everytime --> (performance decrases.)
    2. Leave the first function found. It will warn the second call that (CNumber, int) was expected ... maybe we can reserve the print message
    
  
  


version 1.00.07
===============


-Apply namespace

   


version 1.00.06
===============

-Restructured dir/files
-Added some compatibilities MSVC
-Added zs exec file.


version 1.00.05
===============

CMakeFiles: Added MSVC Comptibility (only compiles with MSVC 2017) that comes with compiler that allows constexpr (sorry)

-take out memmanager.


-Erase utils dir.
Methamethods:
-0. Enumerate total metamethods and access through array + enum index.
-1. Check c++ implementation.
-2. List metamethods to override.
-3. Check correct function signature (ie. only two parameters, return expected type, etc)


Class: 
-1.Test super function.
-2.Class C++
 - 2.1-Class can instanciate with variable parameters. 
       suggestion: implement matamethod function called as _constructor with n parameters to invoke in new CClass(x,x,x) with as many parameters you want.
 - 2.2-Script class heredate with c++ class. Test virtual function.(it doesn t work with params)



-git: create master/develop branch and push code..




 


version 1.00.04b
================
-Added metamethod support. Example use of methamethod add in the class,

class A{

  var x,y;
  
  ...
  
  function _add(var1, var2){
  	var a = new A;
  	a.x = var1.x + var2.x;
  	a.y = var1.y + var2.y;
  }

};



var h = new A(0,1) + new A(1,0); // h should be (1,1)

version 1.00.03b
================

-Added support functions with different parameters.
-Added symbol detection


__symbol: variable symbol
_pN_symbol: function symbol where N is a number that explain the number parameter entry

 
-solved problem double unref shared pointer when rets cscriptvar


version 1.00.02b
================

Change tAleObjectInfo tStackElement

Struct and vectors must hold stack variable instead of CScripVariable.

1. Change CScriptVariable to tStackValue.

1.1- CVector change,
 vector<CScriptVariable *> m_value;
  to
  vector<tStackValue> m_value;

1.2-CStruct

 map <string, CScriptVariable *> m_property;

to

 map <string, tStackValue> m_property;



2. In order to expose script data into C code, implement these functions.

template<_T>
bool tStackValue::instanceof(const tStackValue & stk_v);

template<_T>
_T tStackValue::read(const tStackValue & stk_v);

template<_T>
tStackValue::write(tStackValue & stk_v, const _T & _v);

Warn the user that in native function wether it creates a new variable
function and you pushes into vector or struct is not covered by the script
engine and will crash.

Or maybe in the write function cast an exception that tells is not
possible to override pointers. In other words, write funtion is only for
integers, floats, numbers and strings.

version 1.00.01b
================

- In mov instruction preserve RUNTIME MASK before assign TYPE VAR MASK.
- Remove warning about "dereferencing type-punned pointer will break strict-aliasing rules"
- Test function call.
-



Version 1.00.00b
================

Base version
Exit version