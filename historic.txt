


> implement vector::_toString
> implement struct::_toString
> implement class::_toString 


>Clean code. 
>Test save/restore.
>Remove memory leaks.

> cmake: Add install feature.
> cmake: Add test features
 

> test binary file
> test ternary file
> test if-else file
> test for file
> test while file
> test switch file
> test function file
> test metamethod file (test all override ops. implement _toString metamethod (override for vector & struct))
> test struct file
> test vector file
> test class file
> test c file
  -test calling script function from c and viceversa.
  -test class with c binding
  -test class operators with c binding
  -save/restore state
  -calling script function from C

> Metamethods or C++ call functions fails when it calls from function with different signatures. Example.
  test print error
    
    From C++
    
    class CNumber{
    	float n;
    	
    	...
    	
    	// Metamethods...
    	CNumber * _add(CNumber *n1, int n2);
    	CNumber * _add(CNumber *n1, float n2);
    	
    	...
    	
    }
    
    // In script.
    
    
    function getSumNumber(a1, a2){
    	return a1+a2;
    }
    
    
    var n=new CNumber(0);
    
    ...
    
    getSumNumber(n,0);
    
    ...
    
    getSumNumer(n,1.0); <-- it fails because the first time the _add with INTEGER signature was assigned but now is NUMBER..
    
    
    Solutions:
    
    1. Find the right function everytime --> (performance decrases.)
    2. Leave the first function found. It will warn the second call that (CNumber, int) was expected ... maybe we can reserve the print message
    
//----------------------------------------------------------------------------------------------------------------
// Programmer: Jordi Espada
// version 1.0.0 (Beta)
//


> A lot memory leaks!

- Solved problem not registering C++ variables from base.
- Implement stack overflow process. When problem ocurrs no return NULL. In this case will make a stack overflow.

  the process basically does pop in eac scope in order to unref vars.
   
  !!!!!Warning!!!!! stackdumped will cause some C refs not to be deallocated because aborting main executing thread ... the best thing you can do is
  build a object factory in order to have high control about C pointers in native side not script side.


- alow concatenate string + undefined
- solved bug compiler matching varnames on diferent scopes. For instance,

  {
    var j=0;
  }
  
  {
    var j=0;
  
  }
  
  
  
  this cause a matching names in the scope of the function. The solution is take profit on the same symbol name. In compile time, the variable will be available with no conflict
  due is in diferent scope so they have interfere each other.

- solved problem not initilize the global vars.  
- Solved problem bad initialization of aux_function that caused bad calling function.
- Make more explicit 
 
- solved bug missing C ref property when on = operator.
- solved bug vector add new Elements
- Implement binary constant. For instance 0111011b
> Implement do-while.

-in boolean vars is implicit

if(b==true){
}

it can be the same as,

if(b){

}

BUGS

debug max stack after N calling function from C++ ?



Support for binary contants.
Implement NOT_EQU.
Solved problem preoperator before packed symbol.

Bugs found
==========


var i=0.0;
i=!i; <-- it crashes...

var i=0;

i=true;
i=!i; <-- fails!


-Check property duplicated adding in struct.
-Clear some code.
-Metamethod test in macro
-Added test assign operator with assign in property

TESTS

-test arithmetic int unsigned/signed, float unsigned/signed, mix int/float unsigned/signed.
-test boolean comparison operation.
-test logic op operation. 



-Apply namespace
   

-Restructured dir/files
-Added some compatibilities MSVC
-Added zs exec file.

CMakeFiles: Added MSVC Comptibility (only compiles with MSVC 2017) that comes with compiler that allows constexpr (sorry)

-take out memmanager.


-Erase utils dir.
Methamethods:
-0. Enumerate total metamethods and access through array + enum index.
-1. Check c++ implementation.
-2. List metamethods to override.
-3. Check correct function signature (ie. only two parameters, return expected type, etc)


Class: 
-1.Test super function.
-2.Class C++
 - 2.1-Class can instanciate with variable parameters. 
       suggestion: implement matamethod function called as _constructor with n parameters to invoke in new CClass(x,x,x) with as many parameters you want.
 - 2.2-Script class heredate with c++ class. Test virtual function.(it doesn t work with params)



-git: create master/develop branch and push code..

-Added metamethod support. Example use of methamethod add in the class,

class A{

  var x,y;
  
  ...
  
  function _add(var1, var2){
  	var a = new A;
  	a.x = var1.x + var2.x;
  	a.y = var1.y + var2.y;
  }

};



var h = new A(0,1) + new A(1,0); // h should be (1,1)

-Added support functions with different parameters.
-Added symbol detection


__symbol: variable symbol
_pN_symbol: function symbol where N is a number that explain the number parameter entry

 
-solved problem double unref shared pointer when rets cscriptvar


Change tAleObjectInfo tStackElement

Struct and vectors must hold stack variable instead of CScripVariable.

1. Change CScriptVariable to tStackValue.

1.1- CVectorScriptVariable change,
 vector<CScriptVariable *> m_value;
  to
  vector<tStackValue> m_value;

1.2-CStructScriptVariable

 map <string, CScriptVariable *> m_property;

to

 map <string, tStackValue> m_property;



2. In order to expose script data into C code, implement these functions.

template<_T>
bool tStackValue::instanceof(const tStackValue & stk_v);

template<_T>
_T tStackValue::read(const tStackValue & stk_v);

template<_T>
tStackValue::write(tStackValue & stk_v, const _T & _v);

Warn the user that in native function wether it creates a new variable
function and you pushes into vector or struct is not covered by the script
engine and will crash.

Or maybe in the write function cast an exception that tells is not
possible to override pointers. In other words, write funtion is only for
integers, floats, numbers and strings.

- In mov instruction preserve RUNTIME MASK before assign TYPE VAR MASK.
- Remove warning about "dereferencing type-punned pointer will break strict-aliasing rules"
- Test function call.
-


Base version
Exit version